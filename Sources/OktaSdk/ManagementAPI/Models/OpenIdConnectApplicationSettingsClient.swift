//
// Copyright (c) 2021-Present, Okta, Inc. and/or its affiliates. All rights reserved.
// The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
//
// You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and limitations under the License.
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import AnyCodable

public struct OpenIdConnectApplicationSettingsClient: Codable, Hashable {

    public var applicationType: OpenIdConnectApplicationType?
    public var clientUri: String?
    public var consentMethod: OpenIdConnectApplicationConsentMethod?
    public var grantTypes: [OAuthGrantType]?
    public var initiateLoginUri: String?
    public var issuerMode: OpenIdConnectApplicationIssuerMode?
    public var idpInitiatedLogin: OpenIdConnectApplicationIdpInitiatedLogin?
    public var logoUri: String?
    public var policyUri: String?
    public var postLogoutRedirectUris: [String]?
    public var redirectUris: [String]?
    public var wildcardRedirect: String?
    public var responseTypes: [OAuthResponseType]?
    public var refreshToken: OpenIdConnectApplicationSettingsRefreshToken?
    public var tosUri: String?
    public var jwks: OpenIdConnectApplicationSettingsClientKeys?

    public init(applicationType: OpenIdConnectApplicationType? = nil, clientUri: String? = nil, consentMethod: OpenIdConnectApplicationConsentMethod? = nil, grantTypes: [OAuthGrantType]? = nil, initiateLoginUri: String? = nil, issuerMode: OpenIdConnectApplicationIssuerMode? = nil, idpInitiatedLogin: OpenIdConnectApplicationIdpInitiatedLogin? = nil, logoUri: String? = nil, policyUri: String? = nil, postLogoutRedirectUris: [String]? = nil, redirectUris: [String]? = nil, wildcardRedirect: String? = nil, responseTypes: [OAuthResponseType]? = nil, refreshToken: OpenIdConnectApplicationSettingsRefreshToken? = nil, tosUri: String? = nil, jwks: OpenIdConnectApplicationSettingsClientKeys? = nil) {
        self.applicationType = applicationType
        self.clientUri = clientUri
        self.consentMethod = consentMethod
        self.grantTypes = grantTypes
        self.initiateLoginUri = initiateLoginUri
        self.issuerMode = issuerMode
        self.idpInitiatedLogin = idpInitiatedLogin
        self.logoUri = logoUri
        self.policyUri = policyUri
        self.postLogoutRedirectUris = postLogoutRedirectUris
        self.redirectUris = redirectUris
        self.wildcardRedirect = wildcardRedirect
        self.responseTypes = responseTypes
        self.refreshToken = refreshToken
        self.tosUri = tosUri
        self.jwks = jwks
    }
    public enum CodingKeys: String, CodingKey, CaseIterable {
        case applicationType = "application_type"
        case clientUri = "client_uri"
        case consentMethod = "consent_method"
        case grantTypes = "grant_types"
        case initiateLoginUri = "initiate_login_uri"
        case issuerMode = "issuer_mode"
        case idpInitiatedLogin = "idp_initiated_login"
        case logoUri = "logo_uri"
        case policyUri = "policy_uri"
        case postLogoutRedirectUris = "post_logout_redirect_uris"
        case redirectUris = "redirect_uris"
        case wildcardRedirect = "wildcard_redirect"
        case responseTypes = "response_types"
        case refreshToken = "refresh_token"
        case tosUri = "tos_uri"
        case jwks
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(applicationType, forKey: .applicationType)
        try container.encodeIfPresent(clientUri, forKey: .clientUri)
        try container.encodeIfPresent(consentMethod, forKey: .consentMethod)
        try container.encodeIfPresent(grantTypes, forKey: .grantTypes)
        try container.encodeIfPresent(initiateLoginUri, forKey: .initiateLoginUri)
        try container.encodeIfPresent(issuerMode, forKey: .issuerMode)
        try container.encodeIfPresent(idpInitiatedLogin, forKey: .idpInitiatedLogin)
        try container.encodeIfPresent(logoUri, forKey: .logoUri)
        try container.encodeIfPresent(policyUri, forKey: .policyUri)
        try container.encodeIfPresent(postLogoutRedirectUris, forKey: .postLogoutRedirectUris)
        try container.encodeIfPresent(redirectUris, forKey: .redirectUris)
        try container.encodeIfPresent(wildcardRedirect, forKey: .wildcardRedirect)
        try container.encodeIfPresent(responseTypes, forKey: .responseTypes)
        try container.encodeIfPresent(refreshToken, forKey: .refreshToken)
        try container.encodeIfPresent(tosUri, forKey: .tosUri)
        try container.encodeIfPresent(jwks, forKey: .jwks)
    }



}

