//
// SamlApplicationSettingsSignOn.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import AnyCodable

public final class SamlApplicationSettingsSignOn: Codable, Hashable {

    public var allowMultipleAcsEndpoints: Bool?
    public var acsEndpoints: [AcsEndpoint]?
    public var assertionSigned: Bool?
    public var attributeStatements: [SamlAttributeStatement]?
    public var audience: String?
    public var audienceOverride: String?
    public var authnContextClassRef: String?
    public var defaultRelayState: String?
    public var destination: String?
    public var destinationOverride: String?
    public var digestAlgorithm: String?
    public var honorForceAuthn: Bool?
    public var idpIssuer: String?
    public var recipient: String?
    public var recipientOverride: String?
    public var requestCompressed: Bool?
    public var responseSigned: Bool?
    public var signatureAlgorithm: String?
    public var slo: SingleLogout?
    public var spIssuer: String?
    public var ssoAcsUrl: String?
    public var ssoAcsUrlOverride: String?
    public var spCertificate: SpCertificate?
    public var subjectNameIdFormat: String?
    public var subjectNameIdTemplate: String?

    public init(allowMultipleAcsEndpoints: Bool? = nil, acsEndpoints: [AcsEndpoint]? = nil, assertionSigned: Bool? = nil, attributeStatements: [SamlAttributeStatement]? = nil, audience: String? = nil, audienceOverride: String? = nil, authnContextClassRef: String? = nil, defaultRelayState: String? = nil, destination: String? = nil, destinationOverride: String? = nil, digestAlgorithm: String? = nil, honorForceAuthn: Bool? = nil, idpIssuer: String? = nil, recipient: String? = nil, recipientOverride: String? = nil, requestCompressed: Bool? = nil, responseSigned: Bool? = nil, signatureAlgorithm: String? = nil, slo: SingleLogout? = nil, spIssuer: String? = nil, ssoAcsUrl: String? = nil, ssoAcsUrlOverride: String? = nil, spCertificate: SpCertificate? = nil, subjectNameIdFormat: String? = nil, subjectNameIdTemplate: String? = nil) {
        self.allowMultipleAcsEndpoints = allowMultipleAcsEndpoints
        self.acsEndpoints = acsEndpoints
        self.assertionSigned = assertionSigned
        self.attributeStatements = attributeStatements
        self.audience = audience
        self.audienceOverride = audienceOverride
        self.authnContextClassRef = authnContextClassRef
        self.defaultRelayState = defaultRelayState
        self.destination = destination
        self.destinationOverride = destinationOverride
        self.digestAlgorithm = digestAlgorithm
        self.honorForceAuthn = honorForceAuthn
        self.idpIssuer = idpIssuer
        self.recipient = recipient
        self.recipientOverride = recipientOverride
        self.requestCompressed = requestCompressed
        self.responseSigned = responseSigned
        self.signatureAlgorithm = signatureAlgorithm
        self.slo = slo
        self.spIssuer = spIssuer
        self.ssoAcsUrl = ssoAcsUrl
        self.ssoAcsUrlOverride = ssoAcsUrlOverride
        self.spCertificate = spCertificate
        self.subjectNameIdFormat = subjectNameIdFormat
        self.subjectNameIdTemplate = subjectNameIdTemplate
    }
    public enum CodingKeys: String, CodingKey, CaseIterable {
        case allowMultipleAcsEndpoints
        case acsEndpoints
        case assertionSigned
        case attributeStatements
        case audience
        case audienceOverride
        case authnContextClassRef
        case defaultRelayState
        case destination
        case destinationOverride
        case digestAlgorithm
        case honorForceAuthn
        case idpIssuer
        case recipient
        case recipientOverride
        case requestCompressed
        case responseSigned
        case signatureAlgorithm
        case slo
        case spIssuer
        case ssoAcsUrl
        case ssoAcsUrlOverride
        case spCertificate
        case subjectNameIdFormat
        case subjectNameIdTemplate
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(allowMultipleAcsEndpoints, forKey: .allowMultipleAcsEndpoints)
        try container.encodeIfPresent(acsEndpoints, forKey: .acsEndpoints)
        try container.encodeIfPresent(assertionSigned, forKey: .assertionSigned)
        try container.encodeIfPresent(attributeStatements, forKey: .attributeStatements)
        try container.encodeIfPresent(audience, forKey: .audience)
        try container.encodeIfPresent(audienceOverride, forKey: .audienceOverride)
        try container.encodeIfPresent(authnContextClassRef, forKey: .authnContextClassRef)
        try container.encodeIfPresent(defaultRelayState, forKey: .defaultRelayState)
        try container.encodeIfPresent(destination, forKey: .destination)
        try container.encodeIfPresent(destinationOverride, forKey: .destinationOverride)
        try container.encodeIfPresent(digestAlgorithm, forKey: .digestAlgorithm)
        try container.encodeIfPresent(honorForceAuthn, forKey: .honorForceAuthn)
        try container.encodeIfPresent(idpIssuer, forKey: .idpIssuer)
        try container.encodeIfPresent(recipient, forKey: .recipient)
        try container.encodeIfPresent(recipientOverride, forKey: .recipientOverride)
        try container.encodeIfPresent(requestCompressed, forKey: .requestCompressed)
        try container.encodeIfPresent(responseSigned, forKey: .responseSigned)
        try container.encodeIfPresent(signatureAlgorithm, forKey: .signatureAlgorithm)
        try container.encodeIfPresent(slo, forKey: .slo)
        try container.encodeIfPresent(spIssuer, forKey: .spIssuer)
        try container.encodeIfPresent(ssoAcsUrl, forKey: .ssoAcsUrl)
        try container.encodeIfPresent(ssoAcsUrlOverride, forKey: .ssoAcsUrlOverride)
        try container.encodeIfPresent(spCertificate, forKey: .spCertificate)
        try container.encodeIfPresent(subjectNameIdFormat, forKey: .subjectNameIdFormat)
        try container.encodeIfPresent(subjectNameIdTemplate, forKey: .subjectNameIdTemplate)
    }



    public static func == (lhs: SamlApplicationSettingsSignOn, rhs: SamlApplicationSettingsSignOn) -> Bool {
        lhs.allowMultipleAcsEndpoints == rhs.allowMultipleAcsEndpoints &&
        lhs.acsEndpoints == rhs.acsEndpoints &&
        lhs.assertionSigned == rhs.assertionSigned &&
        lhs.attributeStatements == rhs.attributeStatements &&
        lhs.audience == rhs.audience &&
        lhs.audienceOverride == rhs.audienceOverride &&
        lhs.authnContextClassRef == rhs.authnContextClassRef &&
        lhs.defaultRelayState == rhs.defaultRelayState &&
        lhs.destination == rhs.destination &&
        lhs.destinationOverride == rhs.destinationOverride &&
        lhs.digestAlgorithm == rhs.digestAlgorithm &&
        lhs.honorForceAuthn == rhs.honorForceAuthn &&
        lhs.idpIssuer == rhs.idpIssuer &&
        lhs.recipient == rhs.recipient &&
        lhs.recipientOverride == rhs.recipientOverride &&
        lhs.requestCompressed == rhs.requestCompressed &&
        lhs.responseSigned == rhs.responseSigned &&
        lhs.signatureAlgorithm == rhs.signatureAlgorithm &&
        lhs.slo == rhs.slo &&
        lhs.spIssuer == rhs.spIssuer &&
        lhs.ssoAcsUrl == rhs.ssoAcsUrl &&
        lhs.ssoAcsUrlOverride == rhs.ssoAcsUrlOverride &&
        lhs.spCertificate == rhs.spCertificate &&
        lhs.subjectNameIdFormat == rhs.subjectNameIdFormat &&
        lhs.subjectNameIdTemplate == rhs.subjectNameIdTemplate
        
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(allowMultipleAcsEndpoints?.hashValue)
        hasher.combine(acsEndpoints?.hashValue)
        hasher.combine(assertionSigned?.hashValue)
        hasher.combine(attributeStatements?.hashValue)
        hasher.combine(audience?.hashValue)
        hasher.combine(audienceOverride?.hashValue)
        hasher.combine(authnContextClassRef?.hashValue)
        hasher.combine(defaultRelayState?.hashValue)
        hasher.combine(destination?.hashValue)
        hasher.combine(destinationOverride?.hashValue)
        hasher.combine(digestAlgorithm?.hashValue)
        hasher.combine(honorForceAuthn?.hashValue)
        hasher.combine(idpIssuer?.hashValue)
        hasher.combine(recipient?.hashValue)
        hasher.combine(recipientOverride?.hashValue)
        hasher.combine(requestCompressed?.hashValue)
        hasher.combine(responseSigned?.hashValue)
        hasher.combine(signatureAlgorithm?.hashValue)
        hasher.combine(slo?.hashValue)
        hasher.combine(spIssuer?.hashValue)
        hasher.combine(ssoAcsUrl?.hashValue)
        hasher.combine(ssoAcsUrlOverride?.hashValue)
        hasher.combine(spCertificate?.hashValue)
        hasher.combine(subjectNameIdFormat?.hashValue)
        hasher.combine(subjectNameIdTemplate?.hashValue)
        
    }

}
