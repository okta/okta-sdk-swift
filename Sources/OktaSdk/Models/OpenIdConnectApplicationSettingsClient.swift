//
// OpenIdConnectApplicationSettingsClient.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import AnyCodable

public final class OpenIdConnectApplicationSettingsClient: Codable, Hashable {

    public var applicationType: OpenIdConnectApplicationType?
    public var clientUri: String?
    public var consentMethod: OpenIdConnectApplicationConsentMethod?
    public var grantTypes: [OAuthGrantType]?
    public var initiateLoginUri: String?
    public var issuerMode: OpenIdConnectApplicationIssuerMode?
    public var idpInitiatedLogin: OpenIdConnectApplicationIdpInitiatedLogin?
    public var logoUri: String?
    public var policyUri: String?
    public var postLogoutRedirectUris: [String]?
    public var redirectUris: [String]?
    public var wildcardRedirect: String?
    public var responseTypes: [OAuthResponseType]?
    public var refreshToken: OpenIdConnectApplicationSettingsRefreshToken?
    public var tosUri: String?
    public var jwks: OpenIdConnectApplicationSettingsClientKeys?

    public init(applicationType: OpenIdConnectApplicationType? = nil, clientUri: String? = nil, consentMethod: OpenIdConnectApplicationConsentMethod? = nil, grantTypes: [OAuthGrantType]? = nil, initiateLoginUri: String? = nil, issuerMode: OpenIdConnectApplicationIssuerMode? = nil, idpInitiatedLogin: OpenIdConnectApplicationIdpInitiatedLogin? = nil, logoUri: String? = nil, policyUri: String? = nil, postLogoutRedirectUris: [String]? = nil, redirectUris: [String]? = nil, wildcardRedirect: String? = nil, responseTypes: [OAuthResponseType]? = nil, refreshToken: OpenIdConnectApplicationSettingsRefreshToken? = nil, tosUri: String? = nil, jwks: OpenIdConnectApplicationSettingsClientKeys? = nil) {
        self.applicationType = applicationType
        self.clientUri = clientUri
        self.consentMethod = consentMethod
        self.grantTypes = grantTypes
        self.initiateLoginUri = initiateLoginUri
        self.issuerMode = issuerMode
        self.idpInitiatedLogin = idpInitiatedLogin
        self.logoUri = logoUri
        self.policyUri = policyUri
        self.postLogoutRedirectUris = postLogoutRedirectUris
        self.redirectUris = redirectUris
        self.wildcardRedirect = wildcardRedirect
        self.responseTypes = responseTypes
        self.refreshToken = refreshToken
        self.tosUri = tosUri
        self.jwks = jwks
    }
    public enum CodingKeys: String, CodingKey, CaseIterable {
        case applicationType = "application_type"
        case clientUri = "client_uri"
        case consentMethod = "consent_method"
        case grantTypes = "grant_types"
        case initiateLoginUri = "initiate_login_uri"
        case issuerMode = "issuer_mode"
        case idpInitiatedLogin = "idp_initiated_login"
        case logoUri = "logo_uri"
        case policyUri = "policy_uri"
        case postLogoutRedirectUris = "post_logout_redirect_uris"
        case redirectUris = "redirect_uris"
        case wildcardRedirect = "wildcard_redirect"
        case responseTypes = "response_types"
        case refreshToken = "refresh_token"
        case tosUri = "tos_uri"
        case jwks
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(applicationType, forKey: .applicationType)
        try container.encodeIfPresent(clientUri, forKey: .clientUri)
        try container.encodeIfPresent(consentMethod, forKey: .consentMethod)
        try container.encodeIfPresent(grantTypes, forKey: .grantTypes)
        try container.encodeIfPresent(initiateLoginUri, forKey: .initiateLoginUri)
        try container.encodeIfPresent(issuerMode, forKey: .issuerMode)
        try container.encodeIfPresent(idpInitiatedLogin, forKey: .idpInitiatedLogin)
        try container.encodeIfPresent(logoUri, forKey: .logoUri)
        try container.encodeIfPresent(policyUri, forKey: .policyUri)
        try container.encodeIfPresent(postLogoutRedirectUris, forKey: .postLogoutRedirectUris)
        try container.encodeIfPresent(redirectUris, forKey: .redirectUris)
        try container.encodeIfPresent(wildcardRedirect, forKey: .wildcardRedirect)
        try container.encodeIfPresent(responseTypes, forKey: .responseTypes)
        try container.encodeIfPresent(refreshToken, forKey: .refreshToken)
        try container.encodeIfPresent(tosUri, forKey: .tosUri)
        try container.encodeIfPresent(jwks, forKey: .jwks)
    }



    public static func == (lhs: OpenIdConnectApplicationSettingsClient, rhs: OpenIdConnectApplicationSettingsClient) -> Bool {
        lhs.applicationType == rhs.applicationType &&
        lhs.clientUri == rhs.clientUri &&
        lhs.consentMethod == rhs.consentMethod &&
        lhs.grantTypes == rhs.grantTypes &&
        lhs.initiateLoginUri == rhs.initiateLoginUri &&
        lhs.issuerMode == rhs.issuerMode &&
        lhs.idpInitiatedLogin == rhs.idpInitiatedLogin &&
        lhs.logoUri == rhs.logoUri &&
        lhs.policyUri == rhs.policyUri &&
        lhs.postLogoutRedirectUris == rhs.postLogoutRedirectUris &&
        lhs.redirectUris == rhs.redirectUris &&
        lhs.wildcardRedirect == rhs.wildcardRedirect &&
        lhs.responseTypes == rhs.responseTypes &&
        lhs.refreshToken == rhs.refreshToken &&
        lhs.tosUri == rhs.tosUri &&
        lhs.jwks == rhs.jwks
        
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(applicationType?.hashValue)
        hasher.combine(clientUri?.hashValue)
        hasher.combine(consentMethod?.hashValue)
        hasher.combine(grantTypes?.hashValue)
        hasher.combine(initiateLoginUri?.hashValue)
        hasher.combine(issuerMode?.hashValue)
        hasher.combine(idpInitiatedLogin?.hashValue)
        hasher.combine(logoUri?.hashValue)
        hasher.combine(policyUri?.hashValue)
        hasher.combine(postLogoutRedirectUris?.hashValue)
        hasher.combine(redirectUris?.hashValue)
        hasher.combine(wildcardRedirect?.hashValue)
        hasher.combine(responseTypes?.hashValue)
        hasher.combine(refreshToken?.hashValue)
        hasher.combine(tosUri?.hashValue)
        hasher.combine(jwks?.hashValue)
        
    }

}
