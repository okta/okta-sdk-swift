//
// VerifyFactorRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import AnyCodable

public final class VerifyFactorRequest: Codable, Hashable {

    public var activationToken: String?
    public var answer: String?
    public var attestation: String?
    public var clientData: String?
    public var nextPassCode: String?
    public var passCode: String?
    public var registrationData: String?
    public var stateToken: String?

    public init(activationToken: String? = nil, answer: String? = nil, attestation: String? = nil, clientData: String? = nil, nextPassCode: String? = nil, passCode: String? = nil, registrationData: String? = nil, stateToken: String? = nil) {
        self.activationToken = activationToken
        self.answer = answer
        self.attestation = attestation
        self.clientData = clientData
        self.nextPassCode = nextPassCode
        self.passCode = passCode
        self.registrationData = registrationData
        self.stateToken = stateToken
    }
    public enum CodingKeys: String, CodingKey, CaseIterable {
        case activationToken
        case answer
        case attestation
        case clientData
        case nextPassCode
        case passCode
        case registrationData
        case stateToken
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(activationToken, forKey: .activationToken)
        try container.encodeIfPresent(answer, forKey: .answer)
        try container.encodeIfPresent(attestation, forKey: .attestation)
        try container.encodeIfPresent(clientData, forKey: .clientData)
        try container.encodeIfPresent(nextPassCode, forKey: .nextPassCode)
        try container.encodeIfPresent(passCode, forKey: .passCode)
        try container.encodeIfPresent(registrationData, forKey: .registrationData)
        try container.encodeIfPresent(stateToken, forKey: .stateToken)
    }



    public static func == (lhs: VerifyFactorRequest, rhs: VerifyFactorRequest) -> Bool {
        lhs.activationToken == rhs.activationToken &&
        lhs.answer == rhs.answer &&
        lhs.attestation == rhs.attestation &&
        lhs.clientData == rhs.clientData &&
        lhs.nextPassCode == rhs.nextPassCode &&
        lhs.passCode == rhs.passCode &&
        lhs.registrationData == rhs.registrationData &&
        lhs.stateToken == rhs.stateToken
        
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(activationToken?.hashValue)
        hasher.combine(answer?.hashValue)
        hasher.combine(attestation?.hashValue)
        hasher.combine(clientData?.hashValue)
        hasher.combine(nextPassCode?.hashValue)
        hasher.combine(passCode?.hashValue)
        hasher.combine(registrationData?.hashValue)
        hasher.combine(stateToken?.hashValue)
        
    }

}
