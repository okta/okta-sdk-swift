//
// IdentityProviderAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(Combine)
import Combine
#endif
import AnyCodable

extension OktaSdk.API {


public struct IdentityProviderAPI {
    internal let configuration: OktaClient.Configuration
    internal let queue: DispatchQueue

    internal init(configuration: OktaClient.Configuration, queue: DispatchQueue) {
        self.configuration = configuration
        self.queue = queue
    }

    /**
     Activate Identity Provider
     
     - parameter idpId: (path)  
     - returns: AnyPublisher<IdentityProvider, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func activateIdentityProvider(idpId: String) -> AnyPublisher<IdentityProvider, Error> {
        return Future<IdentityProvider, Error>.init { promise in
            activateIdentityProviderWithRequestBuilder(idpId: idpId).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Activate Identity Provider
     
     - parameter idpId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func activateIdentityProvider(idpId: String, completion: @escaping ((_ result: Swift.Result<IdentityProvider, Error>) -> Void)) {
        activateIdentityProviderWithRequestBuilder(idpId: idpId).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Activate Identity Provider
     - POST /api/v1/idps/{idpId}/lifecycle/activate
     - Activates an inactive IdP.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter idpId: (path)  
     - returns: RequestBuilder<IdentityProvider> 
     */
    public func activateIdentityProviderWithRequestBuilder(idpId: String) -> RequestBuilder<IdentityProvider> {
        var path = "/api/v1/idps/{idpId}/lifecycle/activate"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<IdentityProvider>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Clone Signing Key Credential for IdP
     
     - parameter idpId: (path)  
     - parameter keyId: (path)  
     - parameter targetIdpId: (query)  
     - returns: AnyPublisher<JsonWebKey, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func cloneIdentityProviderKey(idpId: String, keyId: String, targetIdpId: String) -> AnyPublisher<JsonWebKey, Error> {
        return Future<JsonWebKey, Error>.init { promise in
            cloneIdentityProviderKeyWithRequestBuilder(idpId: idpId, keyId: keyId, targetIdpId: targetIdpId).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Clone Signing Key Credential for IdP
     
     - parameter idpId: (path)  
     - parameter keyId: (path)  
     - parameter targetIdpId: (query)  
     - parameter completion: completion handler to receive the result
     */
    func cloneIdentityProviderKey(idpId: String, keyId: String, targetIdpId: String, completion: @escaping ((_ result: Swift.Result<JsonWebKey, Error>) -> Void)) {
        cloneIdentityProviderKeyWithRequestBuilder(idpId: idpId, keyId: keyId, targetIdpId: targetIdpId).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Clone Signing Key Credential for IdP
     - POST /api/v1/idps/{idpId}/credentials/keys/{keyId}/clone
     - Clones a X.509 certificate for an IdP signing key credential from a source IdP to target IdP
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter idpId: (path)  
     - parameter keyId: (path)  
     - parameter targetIdpId: (query)  
     - returns: RequestBuilder<JsonWebKey> 
     */
    public func cloneIdentityProviderKeyWithRequestBuilder(idpId: String, keyId: String, targetIdpId: String) -> RequestBuilder<JsonWebKey> {
        var path = "/api/v1/idps/{idpId}/credentials/keys/{keyId}/clone"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let keyIdPreEscape = "\(APIHelper.mapValueToPathItem(keyId))"
        let keyIdPostEscape = keyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{keyId}", with: keyIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "targetIdpId": targetIdpId.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<JsonWebKey>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Add Identity Provider
     
     - parameter identityProvider: (body)  
     - returns: AnyPublisher<IdentityProvider, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func createIdentityProvider(identityProvider: IdentityProvider) -> AnyPublisher<IdentityProvider, Error> {
        return Future<IdentityProvider, Error>.init { promise in
            createIdentityProviderWithRequestBuilder(identityProvider: identityProvider).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Add Identity Provider
     
     - parameter identityProvider: (body)  
     - parameter completion: completion handler to receive the result
     */
    func createIdentityProvider(identityProvider: IdentityProvider, completion: @escaping ((_ result: Swift.Result<IdentityProvider, Error>) -> Void)) {
        createIdentityProviderWithRequestBuilder(identityProvider: identityProvider).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Add Identity Provider
     - POST /api/v1/idps
     - Adds a new IdP to your organization.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter identityProvider: (body)  
     - returns: RequestBuilder<IdentityProvider> 
     */
    public func createIdentityProviderWithRequestBuilder(identityProvider: IdentityProvider) -> RequestBuilder<IdentityProvider> {
        let path = "/api/v1/idps"
        let URLString = configuration.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: identityProvider)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<IdentityProvider>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Add X.509 Certificate Public Key
     
     - parameter jsonWebKey: (body)  
     - returns: AnyPublisher<JsonWebKey, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func createIdentityProviderKey(jsonWebKey: JsonWebKey) -> AnyPublisher<JsonWebKey, Error> {
        return Future<JsonWebKey, Error>.init { promise in
            createIdentityProviderKeyWithRequestBuilder(jsonWebKey: jsonWebKey).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Add X.509 Certificate Public Key
     
     - parameter jsonWebKey: (body)  
     - parameter completion: completion handler to receive the result
     */
    func createIdentityProviderKey(jsonWebKey: JsonWebKey, completion: @escaping ((_ result: Swift.Result<JsonWebKey, Error>) -> Void)) {
        createIdentityProviderKeyWithRequestBuilder(jsonWebKey: jsonWebKey).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Add X.509 Certificate Public Key
     - POST /api/v1/idps/credentials/keys
     - Adds a new X.509 certificate credential to the IdP key store.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter jsonWebKey: (body)  
     - returns: RequestBuilder<JsonWebKey> 
     */
    public func createIdentityProviderKeyWithRequestBuilder(jsonWebKey: JsonWebKey) -> RequestBuilder<JsonWebKey> {
        let path = "/api/v1/idps/credentials/keys"
        let URLString = configuration.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: jsonWebKey)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<JsonWebKey>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Deactivate Identity Provider
     
     - parameter idpId: (path)  
     - returns: AnyPublisher<IdentityProvider, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func deactivateIdentityProvider(idpId: String) -> AnyPublisher<IdentityProvider, Error> {
        return Future<IdentityProvider, Error>.init { promise in
            deactivateIdentityProviderWithRequestBuilder(idpId: idpId).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Deactivate Identity Provider
     
     - parameter idpId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func deactivateIdentityProvider(idpId: String, completion: @escaping ((_ result: Swift.Result<IdentityProvider, Error>) -> Void)) {
        deactivateIdentityProviderWithRequestBuilder(idpId: idpId).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Deactivate Identity Provider
     - POST /api/v1/idps/{idpId}/lifecycle/deactivate
     - Deactivates an active IdP.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter idpId: (path)  
     - returns: RequestBuilder<IdentityProvider> 
     */
    public func deactivateIdentityProviderWithRequestBuilder(idpId: String) -> RequestBuilder<IdentityProvider> {
        var path = "/api/v1/idps/{idpId}/lifecycle/deactivate"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<IdentityProvider>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Delete Identity Provider
     
     - parameter idpId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func deleteIdentityProvider(idpId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            deleteIdentityProviderWithRequestBuilder(idpId: idpId).execute(queue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Delete Identity Provider
     
     - parameter idpId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func deleteIdentityProvider(idpId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        deleteIdentityProviderWithRequestBuilder(idpId: idpId).execute(queue) { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Delete Identity Provider
     - DELETE /api/v1/idps/{idpId}
     - Removes an IdP from your organization.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter idpId: (path)  
     - returns: RequestBuilder<Void> 
     */
    public func deleteIdentityProviderWithRequestBuilder(idpId: String) -> RequestBuilder<Void> {
        var path = "/api/v1/idps/{idpId}"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = OktaSdkAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Delete Key
     
     - parameter keyId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func deleteIdentityProviderKey(keyId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            deleteIdentityProviderKeyWithRequestBuilder(keyId: keyId).execute(queue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Delete Key
     
     - parameter keyId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func deleteIdentityProviderKey(keyId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        deleteIdentityProviderKeyWithRequestBuilder(keyId: keyId).execute(queue) { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Delete Key
     - DELETE /api/v1/idps/credentials/keys/{keyId}
     - Deletes a specific IdP Key Credential by `kid` if it is not currently being used by an Active or Inactive IdP.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter keyId: (path)  
     - returns: RequestBuilder<Void> 
     */
    public func deleteIdentityProviderKeyWithRequestBuilder(keyId: String) -> RequestBuilder<Void> {
        var path = "/api/v1/idps/credentials/keys/{keyId}"
        let keyIdPreEscape = "\(APIHelper.mapValueToPathItem(keyId))"
        let keyIdPostEscape = keyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{keyId}", with: keyIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = OktaSdkAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Generate Certificate Signing Request for IdP
     
     - parameter idpId: (path)  
     - parameter metadata: (body)  
     - returns: AnyPublisher<Csr, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func generateCsrForIdentityProvider(idpId: String, metadata: CsrMetadata) -> AnyPublisher<Csr, Error> {
        return Future<Csr, Error>.init { promise in
            generateCsrForIdentityProviderWithRequestBuilder(idpId: idpId, metadata: metadata).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Generate Certificate Signing Request for IdP
     
     - parameter idpId: (path)  
     - parameter metadata: (body)  
     - parameter completion: completion handler to receive the result
     */
    func generateCsrForIdentityProvider(idpId: String, metadata: CsrMetadata, completion: @escaping ((_ result: Swift.Result<Csr, Error>) -> Void)) {
        generateCsrForIdentityProviderWithRequestBuilder(idpId: idpId, metadata: metadata).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Generate Certificate Signing Request for IdP
     - POST /api/v1/idps/{idpId}/credentials/csrs
     - Generates a new key pair and returns a Certificate Signing Request for it.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter idpId: (path)  
     - parameter metadata: (body)  
     - returns: RequestBuilder<Csr> 
     */
    public func generateCsrForIdentityProviderWithRequestBuilder(idpId: String, metadata: CsrMetadata) -> RequestBuilder<Csr> {
        var path = "/api/v1/idps/{idpId}/credentials/csrs"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: metadata)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Csr>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Generate New IdP Signing Key Credential
     
     - parameter idpId: (path)  
     - parameter validityYears: (query) expiry of the IdP Key Credential 
     - returns: AnyPublisher<JsonWebKey, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func generateIdentityProviderSigningKey(idpId: String, validityYears: Int) -> AnyPublisher<JsonWebKey, Error> {
        return Future<JsonWebKey, Error>.init { promise in
            generateIdentityProviderSigningKeyWithRequestBuilder(idpId: idpId, validityYears: validityYears).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Generate New IdP Signing Key Credential
     
     - parameter idpId: (path)  
     - parameter validityYears: (query) expiry of the IdP Key Credential 
     - parameter completion: completion handler to receive the result
     */
    func generateIdentityProviderSigningKey(idpId: String, validityYears: Int, completion: @escaping ((_ result: Swift.Result<JsonWebKey, Error>) -> Void)) {
        generateIdentityProviderSigningKeyWithRequestBuilder(idpId: idpId, validityYears: validityYears).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Generate New IdP Signing Key Credential
     - POST /api/v1/idps/{idpId}/credentials/keys/generate
     - Generates a new X.509 certificate for an IdP signing key credential to be used for signing assertions sent to the IdP
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter idpId: (path)  
     - parameter validityYears: (query) expiry of the IdP Key Credential 
     - returns: RequestBuilder<JsonWebKey> 
     */
    public func generateIdentityProviderSigningKeyWithRequestBuilder(idpId: String, validityYears: Int) -> RequestBuilder<JsonWebKey> {
        var path = "/api/v1/idps/{idpId}/credentials/keys/generate"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "validityYears": validityYears.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<JsonWebKey>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter idpId: (path)  
     - parameter csrId: (path)  
     - returns: AnyPublisher<Csr, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getCsrForIdentityProvider(idpId: String, csrId: String) -> AnyPublisher<Csr, Error> {
        return Future<Csr, Error>.init { promise in
            getCsrForIdentityProviderWithRequestBuilder(idpId: idpId, csrId: csrId).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter idpId: (path)  
     - parameter csrId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func getCsrForIdentityProvider(idpId: String, csrId: String, completion: @escaping ((_ result: Swift.Result<Csr, Error>) -> Void)) {
        getCsrForIdentityProviderWithRequestBuilder(idpId: idpId, csrId: csrId).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     - GET /api/v1/idps/{idpId}/credentials/csrs/{csrId}
     - Gets a specific Certificate Signing Request model by id
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter idpId: (path)  
     - parameter csrId: (path)  
     - returns: RequestBuilder<Csr> 
     */
    public func getCsrForIdentityProviderWithRequestBuilder(idpId: String, csrId: String) -> RequestBuilder<Csr> {
        var path = "/api/v1/idps/{idpId}/credentials/csrs/{csrId}"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let csrIdPreEscape = "\(APIHelper.mapValueToPathItem(csrId))"
        let csrIdPostEscape = csrIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{csrId}", with: csrIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Csr>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get Identity Provider
     
     - parameter idpId: (path)  
     - returns: AnyPublisher<IdentityProvider, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getIdentityProvider(idpId: String) -> AnyPublisher<IdentityProvider, Error> {
        return Future<IdentityProvider, Error>.init { promise in
            getIdentityProviderWithRequestBuilder(idpId: idpId).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Get Identity Provider
     
     - parameter idpId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func getIdentityProvider(idpId: String, completion: @escaping ((_ result: Swift.Result<IdentityProvider, Error>) -> Void)) {
        getIdentityProviderWithRequestBuilder(idpId: idpId).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Get Identity Provider
     - GET /api/v1/idps/{idpId}
     - Fetches an IdP by `id`.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter idpId: (path)  
     - returns: RequestBuilder<IdentityProvider> 
     */
    public func getIdentityProviderWithRequestBuilder(idpId: String) -> RequestBuilder<IdentityProvider> {
        var path = "/api/v1/idps/{idpId}"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<IdentityProvider>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter idpId: (path)  
     - parameter userId: (path)  
     - returns: AnyPublisher<IdentityProviderApplicationUser, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getIdentityProviderApplicationUser(idpId: String, userId: String) -> AnyPublisher<IdentityProviderApplicationUser, Error> {
        return Future<IdentityProviderApplicationUser, Error>.init { promise in
            getIdentityProviderApplicationUserWithRequestBuilder(idpId: idpId, userId: userId).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter idpId: (path)  
     - parameter userId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func getIdentityProviderApplicationUser(idpId: String, userId: String, completion: @escaping ((_ result: Swift.Result<IdentityProviderApplicationUser, Error>) -> Void)) {
        getIdentityProviderApplicationUserWithRequestBuilder(idpId: idpId, userId: userId).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     - GET /api/v1/idps/{idpId}/users/{userId}
     - Fetches a linked IdP user by ID
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter idpId: (path)  
     - parameter userId: (path)  
     - returns: RequestBuilder<IdentityProviderApplicationUser> 
     */
    public func getIdentityProviderApplicationUserWithRequestBuilder(idpId: String, userId: String) -> RequestBuilder<IdentityProviderApplicationUser> {
        var path = "/api/v1/idps/{idpId}/users/{userId}"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<IdentityProviderApplicationUser>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get Key
     
     - parameter keyId: (path)  
     - returns: AnyPublisher<JsonWebKey, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getIdentityProviderKey(keyId: String) -> AnyPublisher<JsonWebKey, Error> {
        return Future<JsonWebKey, Error>.init { promise in
            getIdentityProviderKeyWithRequestBuilder(keyId: keyId).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Get Key
     
     - parameter keyId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func getIdentityProviderKey(keyId: String, completion: @escaping ((_ result: Swift.Result<JsonWebKey, Error>) -> Void)) {
        getIdentityProviderKeyWithRequestBuilder(keyId: keyId).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Get Key
     - GET /api/v1/idps/credentials/keys/{keyId}
     - Gets a specific IdP Key Credential by `kid`
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter keyId: (path)  
     - returns: RequestBuilder<JsonWebKey> 
     */
    public func getIdentityProviderKeyWithRequestBuilder(keyId: String) -> RequestBuilder<JsonWebKey> {
        var path = "/api/v1/idps/credentials/keys/{keyId}"
        let keyIdPreEscape = "\(APIHelper.mapValueToPathItem(keyId))"
        let keyIdPostEscape = keyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{keyId}", with: keyIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<JsonWebKey>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get Signing Key Credential for IdP
     
     - parameter idpId: (path)  
     - parameter keyId: (path)  
     - returns: AnyPublisher<JsonWebKey, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getIdentityProviderSigningKey(idpId: String, keyId: String) -> AnyPublisher<JsonWebKey, Error> {
        return Future<JsonWebKey, Error>.init { promise in
            getIdentityProviderSigningKeyWithRequestBuilder(idpId: idpId, keyId: keyId).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Get Signing Key Credential for IdP
     
     - parameter idpId: (path)  
     - parameter keyId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func getIdentityProviderSigningKey(idpId: String, keyId: String, completion: @escaping ((_ result: Swift.Result<JsonWebKey, Error>) -> Void)) {
        getIdentityProviderSigningKeyWithRequestBuilder(idpId: idpId, keyId: keyId).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Get Signing Key Credential for IdP
     - GET /api/v1/idps/{idpId}/credentials/keys/{keyId}
     - Gets a specific IdP Key Credential by `kid`
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter idpId: (path)  
     - parameter keyId: (path)  
     - returns: RequestBuilder<JsonWebKey> 
     */
    public func getIdentityProviderSigningKeyWithRequestBuilder(idpId: String, keyId: String) -> RequestBuilder<JsonWebKey> {
        var path = "/api/v1/idps/{idpId}/credentials/keys/{keyId}"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let keyIdPreEscape = "\(APIHelper.mapValueToPathItem(keyId))"
        let keyIdPostEscape = keyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{keyId}", with: keyIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<JsonWebKey>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Link a user to a Social IdP without a transaction
     
     - parameter idpId: (path)  
     - parameter userId: (path)  
     - parameter userIdentityProviderLinkRequest: (body)  
     - returns: AnyPublisher<IdentityProviderApplicationUser, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func linkUserToIdentityProvider(idpId: String, userId: String, userIdentityProviderLinkRequest: UserIdentityProviderLinkRequest) -> AnyPublisher<IdentityProviderApplicationUser, Error> {
        return Future<IdentityProviderApplicationUser, Error>.init { promise in
            linkUserToIdentityProviderWithRequestBuilder(idpId: idpId, userId: userId, userIdentityProviderLinkRequest: userIdentityProviderLinkRequest).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Link a user to a Social IdP without a transaction
     
     - parameter idpId: (path)  
     - parameter userId: (path)  
     - parameter userIdentityProviderLinkRequest: (body)  
     - parameter completion: completion handler to receive the result
     */
    func linkUserToIdentityProvider(idpId: String, userId: String, userIdentityProviderLinkRequest: UserIdentityProviderLinkRequest, completion: @escaping ((_ result: Swift.Result<IdentityProviderApplicationUser, Error>) -> Void)) {
        linkUserToIdentityProviderWithRequestBuilder(idpId: idpId, userId: userId, userIdentityProviderLinkRequest: userIdentityProviderLinkRequest).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Link a user to a Social IdP without a transaction
     - POST /api/v1/idps/{idpId}/users/{userId}
     - Links an Okta user to an existing Social Identity Provider. This does not support the SAML2 Identity Provider Type
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter idpId: (path)  
     - parameter userId: (path)  
     - parameter userIdentityProviderLinkRequest: (body)  
     - returns: RequestBuilder<IdentityProviderApplicationUser> 
     */
    public func linkUserToIdentityProviderWithRequestBuilder(idpId: String, userId: String, userIdentityProviderLinkRequest: UserIdentityProviderLinkRequest) -> RequestBuilder<IdentityProviderApplicationUser> {
        var path = "/api/v1/idps/{idpId}/users/{userId}"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: userIdentityProviderLinkRequest)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<IdentityProviderApplicationUser>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     List Certificate Signing Requests for IdP
     
     - parameter idpId: (path)  
     - returns: AnyPublisher<[Csr], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listCsrsForIdentityProvider(idpId: String) -> AnyPublisher<[Csr], Error> {
        return Future<[Csr], Error>.init { promise in
            listCsrsForIdentityProviderWithRequestBuilder(idpId: idpId).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     List Certificate Signing Requests for IdP
     
     - parameter idpId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func listCsrsForIdentityProvider(idpId: String, completion: @escaping ((_ result: Swift.Result<[Csr], Error>) -> Void)) {
        listCsrsForIdentityProviderWithRequestBuilder(idpId: idpId).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     List Certificate Signing Requests for IdP
     - GET /api/v1/idps/{idpId}/credentials/csrs
     - Enumerates Certificate Signing Requests for an IdP
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter idpId: (path)  
     - returns: RequestBuilder<[Csr]> 
     */
    public func listCsrsForIdentityProviderWithRequestBuilder(idpId: String) -> RequestBuilder<[Csr]> {
        var path = "/api/v1/idps/{idpId}/credentials/csrs"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[Csr]>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Find Users
     
     - parameter idpId: (path)  
     - returns: AnyPublisher<[IdentityProviderApplicationUser], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listIdentityProviderApplicationUsers(idpId: String) -> AnyPublisher<[IdentityProviderApplicationUser], Error> {
        return Future<[IdentityProviderApplicationUser], Error>.init { promise in
            listIdentityProviderApplicationUsersWithRequestBuilder(idpId: idpId).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Find Users
     
     - parameter idpId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func listIdentityProviderApplicationUsers(idpId: String, completion: @escaping ((_ result: Swift.Result<[IdentityProviderApplicationUser], Error>) -> Void)) {
        listIdentityProviderApplicationUsersWithRequestBuilder(idpId: idpId).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Find Users
     - GET /api/v1/idps/{idpId}/users
     - Find all the users linked to an identity provider
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter idpId: (path)  
     - returns: RequestBuilder<[IdentityProviderApplicationUser]> 
     */
    public func listIdentityProviderApplicationUsersWithRequestBuilder(idpId: String) -> RequestBuilder<[IdentityProviderApplicationUser]> {
        var path = "/api/v1/idps/{idpId}/users"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[IdentityProviderApplicationUser]>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     List Keys
     
     - parameter after: (query) Specifies the pagination cursor for the next page of keys (optional)
     - parameter limit: (query) Specifies the number of key results in a page (optional, default to 20)
     - returns: AnyPublisher<[JsonWebKey], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listIdentityProviderKeys(after: String? = nil, limit: Int? = nil) -> AnyPublisher<[JsonWebKey], Error> {
        return Future<[JsonWebKey], Error>.init { promise in
            listIdentityProviderKeysWithRequestBuilder(after: after, limit: limit).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     List Keys
     
     - parameter after: (query) Specifies the pagination cursor for the next page of keys (optional)
     - parameter limit: (query) Specifies the number of key results in a page (optional, default to 20)
     - parameter completion: completion handler to receive the result
     */
    func listIdentityProviderKeys(after: String? = nil, limit: Int? = nil, completion: @escaping ((_ result: Swift.Result<[JsonWebKey], Error>) -> Void)) {
        listIdentityProviderKeysWithRequestBuilder(after: after, limit: limit).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     List Keys
     - GET /api/v1/idps/credentials/keys
     - Enumerates IdP key credentials.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter after: (query) Specifies the pagination cursor for the next page of keys (optional)
     - parameter limit: (query) Specifies the number of key results in a page (optional, default to 20)
     - returns: RequestBuilder<[JsonWebKey]> 
     */
    public func listIdentityProviderKeysWithRequestBuilder(after: String? = nil, limit: Int? = nil) -> RequestBuilder<[JsonWebKey]> {
        let path = "/api/v1/idps/credentials/keys"
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "after": after?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[JsonWebKey]>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     List Signing Key Credentials for IdP
     
     - parameter idpId: (path)  
     - returns: AnyPublisher<[JsonWebKey], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listIdentityProviderSigningKeys(idpId: String) -> AnyPublisher<[JsonWebKey], Error> {
        return Future<[JsonWebKey], Error>.init { promise in
            listIdentityProviderSigningKeysWithRequestBuilder(idpId: idpId).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     List Signing Key Credentials for IdP
     
     - parameter idpId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func listIdentityProviderSigningKeys(idpId: String, completion: @escaping ((_ result: Swift.Result<[JsonWebKey], Error>) -> Void)) {
        listIdentityProviderSigningKeysWithRequestBuilder(idpId: idpId).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     List Signing Key Credentials for IdP
     - GET /api/v1/idps/{idpId}/credentials/keys
     - Enumerates signing key credentials for an IdP
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter idpId: (path)  
     - returns: RequestBuilder<[JsonWebKey]> 
     */
    public func listIdentityProviderSigningKeysWithRequestBuilder(idpId: String) -> RequestBuilder<[JsonWebKey]> {
        var path = "/api/v1/idps/{idpId}/credentials/keys"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[JsonWebKey]>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     List Identity Providers
     
     - parameter q: (query) Searches the name property of IdPs for matching value (optional)
     - parameter after: (query) Specifies the pagination cursor for the next page of IdPs (optional)
     - parameter limit: (query) Specifies the number of IdP results in a page (optional, default to 20)
     - parameter type: (query) Filters IdPs by type (optional)
     - returns: AnyPublisher<[IdentityProvider], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listIdentityProviders(q: String? = nil, after: String? = nil, limit: Int? = nil, type: String? = nil) -> AnyPublisher<[IdentityProvider], Error> {
        return Future<[IdentityProvider], Error>.init { promise in
            listIdentityProvidersWithRequestBuilder(q: q, after: after, limit: limit, type: type).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     List Identity Providers
     
     - parameter q: (query) Searches the name property of IdPs for matching value (optional)
     - parameter after: (query) Specifies the pagination cursor for the next page of IdPs (optional)
     - parameter limit: (query) Specifies the number of IdP results in a page (optional, default to 20)
     - parameter type: (query) Filters IdPs by type (optional)
     - parameter completion: completion handler to receive the result
     */
    func listIdentityProviders(q: String? = nil, after: String? = nil, limit: Int? = nil, type: String? = nil, completion: @escaping ((_ result: Swift.Result<[IdentityProvider], Error>) -> Void)) {
        listIdentityProvidersWithRequestBuilder(q: q, after: after, limit: limit, type: type).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     List Identity Providers
     - GET /api/v1/idps
     - Enumerates IdPs in your organization with pagination. A subset of IdPs can be returned that match a supported filter expression or query.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter q: (query) Searches the name property of IdPs for matching value (optional)
     - parameter after: (query) Specifies the pagination cursor for the next page of IdPs (optional)
     - parameter limit: (query) Specifies the number of IdP results in a page (optional, default to 20)
     - parameter type: (query) Filters IdPs by type (optional)
     - returns: RequestBuilder<[IdentityProvider]> 
     */
    public func listIdentityProvidersWithRequestBuilder(q: String? = nil, after: String? = nil, limit: Int? = nil, type: String? = nil) -> RequestBuilder<[IdentityProvider]> {
        let path = "/api/v1/idps"
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "q": q?.encodeToJSON(),
            "after": after?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "type": type?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[IdentityProvider]>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Social Authentication Token Operation
     
     - parameter idpId: (path)  
     - parameter userId: (path)  
     - returns: AnyPublisher<[SocialAuthToken], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listSocialAuthTokens(idpId: String, userId: String) -> AnyPublisher<[SocialAuthToken], Error> {
        return Future<[SocialAuthToken], Error>.init { promise in
            listSocialAuthTokensWithRequestBuilder(idpId: idpId, userId: userId).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Social Authentication Token Operation
     
     - parameter idpId: (path)  
     - parameter userId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func listSocialAuthTokens(idpId: String, userId: String, completion: @escaping ((_ result: Swift.Result<[SocialAuthToken], Error>) -> Void)) {
        listSocialAuthTokensWithRequestBuilder(idpId: idpId, userId: userId).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Social Authentication Token Operation
     - GET /api/v1/idps/{idpId}/users/{userId}/credentials/tokens
     - Fetches the tokens minted by the Social Authentication Provider when the user authenticates with Okta via Social Auth.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter idpId: (path)  
     - parameter userId: (path)  
     - returns: RequestBuilder<[SocialAuthToken]> 
     */
    public func listSocialAuthTokensWithRequestBuilder(idpId: String, userId: String) -> RequestBuilder<[SocialAuthToken]> {
        var path = "/api/v1/idps/{idpId}/users/{userId}/credentials/tokens"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[SocialAuthToken]>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter idpId: (path)  
     - parameter csrId: (path)  
     - returns: AnyPublisher<JsonWebKey, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func publishCsrForIdentityProvider(idpId: String, csrId: String) -> AnyPublisher<JsonWebKey, Error> {
        return Future<JsonWebKey, Error>.init { promise in
            publishCsrForIdentityProviderWithRequestBuilder(idpId: idpId, csrId: csrId).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter idpId: (path)  
     - parameter csrId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func publishCsrForIdentityProvider(idpId: String, csrId: String, completion: @escaping ((_ result: Swift.Result<JsonWebKey, Error>) -> Void)) {
        publishCsrForIdentityProviderWithRequestBuilder(idpId: idpId, csrId: csrId).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     - POST /api/v1/idps/{idpId}/credentials/csrs/{csrId}/lifecycle/publish
     - Update the Certificate Signing Request with a signed X.509 certificate and add it into the signing key credentials for the IdP.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter idpId: (path)  
     - parameter csrId: (path)  
     - returns: RequestBuilder<JsonWebKey> 
     */
    public func publishCsrForIdentityProviderWithRequestBuilder(idpId: String, csrId: String) -> RequestBuilder<JsonWebKey> {
        var path = "/api/v1/idps/{idpId}/credentials/csrs/{csrId}/lifecycle/publish"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let csrIdPreEscape = "\(APIHelper.mapValueToPathItem(csrId))"
        let csrIdPostEscape = csrIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{csrId}", with: csrIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<JsonWebKey>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter idpId: (path)  
     - parameter csrId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func revokeCsrForIdentityProvider(idpId: String, csrId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            revokeCsrForIdentityProviderWithRequestBuilder(idpId: idpId, csrId: csrId).execute(queue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter idpId: (path)  
     - parameter csrId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func revokeCsrForIdentityProvider(idpId: String, csrId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        revokeCsrForIdentityProviderWithRequestBuilder(idpId: idpId, csrId: csrId).execute(queue) { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     - DELETE /api/v1/idps/{idpId}/credentials/csrs/{csrId}
     - Revoke a Certificate Signing Request and delete the key pair from the IdP
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter idpId: (path)  
     - parameter csrId: (path)  
     - returns: RequestBuilder<Void> 
     */
    public func revokeCsrForIdentityProviderWithRequestBuilder(idpId: String, csrId: String) -> RequestBuilder<Void> {
        var path = "/api/v1/idps/{idpId}/credentials/csrs/{csrId}"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let csrIdPreEscape = "\(APIHelper.mapValueToPathItem(csrId))"
        let csrIdPostEscape = csrIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{csrId}", with: csrIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = OktaSdkAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Unlink User from IdP
     
     - parameter idpId: (path)  
     - parameter userId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func unlinkUserFromIdentityProvider(idpId: String, userId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            unlinkUserFromIdentityProviderWithRequestBuilder(idpId: idpId, userId: userId).execute(queue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Unlink User from IdP
     
     - parameter idpId: (path)  
     - parameter userId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func unlinkUserFromIdentityProvider(idpId: String, userId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        unlinkUserFromIdentityProviderWithRequestBuilder(idpId: idpId, userId: userId).execute(queue) { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Unlink User from IdP
     - DELETE /api/v1/idps/{idpId}/users/{userId}
     - Removes the link between the Okta user and the IdP user.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter idpId: (path)  
     - parameter userId: (path)  
     - returns: RequestBuilder<Void> 
     */
    public func unlinkUserFromIdentityProviderWithRequestBuilder(idpId: String, userId: String) -> RequestBuilder<Void> {
        var path = "/api/v1/idps/{idpId}/users/{userId}"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = OktaSdkAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Update Identity Provider
     
     - parameter idpId: (path)  
     - parameter identityProvider: (body)  
     - returns: AnyPublisher<IdentityProvider, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func updateIdentityProvider(idpId: String, identityProvider: IdentityProvider) -> AnyPublisher<IdentityProvider, Error> {
        return Future<IdentityProvider, Error>.init { promise in
            updateIdentityProviderWithRequestBuilder(idpId: idpId, identityProvider: identityProvider).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Update Identity Provider
     
     - parameter idpId: (path)  
     - parameter identityProvider: (body)  
     - parameter completion: completion handler to receive the result
     */
    func updateIdentityProvider(idpId: String, identityProvider: IdentityProvider, completion: @escaping ((_ result: Swift.Result<IdentityProvider, Error>) -> Void)) {
        updateIdentityProviderWithRequestBuilder(idpId: idpId, identityProvider: identityProvider).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Update Identity Provider
     - PUT /api/v1/idps/{idpId}
     - Updates the configuration for an IdP.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter idpId: (path)  
     - parameter identityProvider: (body)  
     - returns: RequestBuilder<IdentityProvider> 
     */
    public func updateIdentityProviderWithRequestBuilder(idpId: String, identityProvider: IdentityProvider) -> RequestBuilder<IdentityProvider> {
        var path = "/api/v1/idps/{idpId}"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: identityProvider)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<IdentityProvider>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "PUT", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

}
}
