//
// IdentityProviderAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(Combine)
import Combine
#endif
import AnyCodable

extension OktaSdk.API {


public class IdentityProviderAPI {
    internal weak var api: OktaSdkAPI?

    internal init(api: OktaSdkAPI) {
        self.api = api
    }

    /**
     Activate Identity Provider
     
     - parameter idpId: (path)  
     - returns: AnyPublisher<IdentityProvider, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func activateIdentityProvider(idpId: String) -> AnyPublisher<IdentityProvider, Error> {
        return Future<IdentityProvider, Error>.init { promise in
            guard let builder = self.activateIdentityProviderWithRequestBuilder(idpId: idpId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Activate Identity Provider
     
     - parameter idpId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func activateIdentityProvider(idpId: String, completion: @escaping ((_ result: Swift.Result<IdentityProvider, Error>) -> Void)) {
        guard let builder = activateIdentityProviderWithRequestBuilder(idpId: idpId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func activateIdentityProviderWithRequestBuilder(idpId: String) -> RequestBuilder<IdentityProvider>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/idps/{idpId}/lifecycle/activate"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<IdentityProvider>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Clone Signing Key Credential for IdP
     
     - parameter idpId: (path)  
     - parameter keyId: (path)  
     - parameter targetIdpId: (query)  
     - returns: AnyPublisher<JsonWebKey, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func cloneIdentityProviderKey(idpId: String, keyId: String, targetIdpId: String) -> AnyPublisher<JsonWebKey, Error> {
        return Future<JsonWebKey, Error>.init { promise in
            guard let builder = self.cloneIdentityProviderKeyWithRequestBuilder(idpId: idpId, keyId: keyId, targetIdpId: targetIdpId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Clone Signing Key Credential for IdP
     
     - parameter idpId: (path)  
     - parameter keyId: (path)  
     - parameter targetIdpId: (query)  
     - parameter completion: completion handler to receive the result
     */
    func cloneIdentityProviderKey(idpId: String, keyId: String, targetIdpId: String, completion: @escaping ((_ result: Swift.Result<JsonWebKey, Error>) -> Void)) {
        guard let builder = cloneIdentityProviderKeyWithRequestBuilder(idpId: idpId, keyId: keyId, targetIdpId: targetIdpId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func cloneIdentityProviderKeyWithRequestBuilder(idpId: String, keyId: String, targetIdpId: String) -> RequestBuilder<JsonWebKey>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/idps/{idpId}/credentials/keys/{keyId}/clone"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let keyIdPreEscape = "\(APIHelper.mapValueToPathItem(keyId))"
        let keyIdPostEscape = keyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{keyId}", with: keyIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "targetIdpId": targetIdpId.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<JsonWebKey>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Add Identity Provider
     
     - parameter identityProvider: (body)  
     - returns: AnyPublisher<IdentityProvider, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func createIdentityProvider(identityProvider: IdentityProvider) -> AnyPublisher<IdentityProvider, Error> {
        return Future<IdentityProvider, Error>.init { promise in
            guard let builder = self.createIdentityProviderWithRequestBuilder(identityProvider: identityProvider) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Add Identity Provider
     
     - parameter identityProvider: (body)  
     - parameter completion: completion handler to receive the result
     */
    func createIdentityProvider(identityProvider: IdentityProvider, completion: @escaping ((_ result: Swift.Result<IdentityProvider, Error>) -> Void)) {
        guard let builder = createIdentityProviderWithRequestBuilder(identityProvider: identityProvider) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func createIdentityProviderWithRequestBuilder(identityProvider: IdentityProvider) -> RequestBuilder<IdentityProvider>? {
        guard let api = api else {
            return nil
        }
        let path = "/api/v1/idps"
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: identityProvider)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<IdentityProvider>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Add X.509 Certificate Public Key
     
     - parameter jsonWebKey: (body)  
     - returns: AnyPublisher<JsonWebKey, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func createIdentityProviderKey(jsonWebKey: JsonWebKey) -> AnyPublisher<JsonWebKey, Error> {
        return Future<JsonWebKey, Error>.init { promise in
            guard let builder = self.createIdentityProviderKeyWithRequestBuilder(jsonWebKey: jsonWebKey) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Add X.509 Certificate Public Key
     
     - parameter jsonWebKey: (body)  
     - parameter completion: completion handler to receive the result
     */
    func createIdentityProviderKey(jsonWebKey: JsonWebKey, completion: @escaping ((_ result: Swift.Result<JsonWebKey, Error>) -> Void)) {
        guard let builder = createIdentityProviderKeyWithRequestBuilder(jsonWebKey: jsonWebKey) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func createIdentityProviderKeyWithRequestBuilder(jsonWebKey: JsonWebKey) -> RequestBuilder<JsonWebKey>? {
        guard let api = api else {
            return nil
        }
        let path = "/api/v1/idps/credentials/keys"
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: jsonWebKey)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<JsonWebKey>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Deactivate Identity Provider
     
     - parameter idpId: (path)  
     - returns: AnyPublisher<IdentityProvider, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func deactivateIdentityProvider(idpId: String) -> AnyPublisher<IdentityProvider, Error> {
        return Future<IdentityProvider, Error>.init { promise in
            guard let builder = self.deactivateIdentityProviderWithRequestBuilder(idpId: idpId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Deactivate Identity Provider
     
     - parameter idpId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func deactivateIdentityProvider(idpId: String, completion: @escaping ((_ result: Swift.Result<IdentityProvider, Error>) -> Void)) {
        guard let builder = deactivateIdentityProviderWithRequestBuilder(idpId: idpId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func deactivateIdentityProviderWithRequestBuilder(idpId: String) -> RequestBuilder<IdentityProvider>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/idps/{idpId}/lifecycle/deactivate"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<IdentityProvider>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Delete Identity Provider
     
     - parameter idpId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func deleteIdentityProvider(idpId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.deleteIdentityProviderWithRequestBuilder(idpId: idpId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Delete Identity Provider
     
     - parameter idpId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func deleteIdentityProvider(idpId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = deleteIdentityProviderWithRequestBuilder(idpId: idpId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func deleteIdentityProviderWithRequestBuilder(idpId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/idps/{idpId}"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Delete Key
     
     - parameter keyId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func deleteIdentityProviderKey(keyId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.deleteIdentityProviderKeyWithRequestBuilder(keyId: keyId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Delete Key
     
     - parameter keyId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func deleteIdentityProviderKey(keyId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = deleteIdentityProviderKeyWithRequestBuilder(keyId: keyId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func deleteIdentityProviderKeyWithRequestBuilder(keyId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/idps/credentials/keys/{keyId}"
        let keyIdPreEscape = "\(APIHelper.mapValueToPathItem(keyId))"
        let keyIdPostEscape = keyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{keyId}", with: keyIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Generate Certificate Signing Request for IdP
     
     - parameter idpId: (path)  
     - parameter metadata: (body)  
     - returns: AnyPublisher<Csr, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func generateCsrForIdentityProvider(idpId: String, metadata: CsrMetadata) -> AnyPublisher<Csr, Error> {
        return Future<Csr, Error>.init { promise in
            guard let builder = self.generateCsrForIdentityProviderWithRequestBuilder(idpId: idpId, metadata: metadata) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Generate Certificate Signing Request for IdP
     
     - parameter idpId: (path)  
     - parameter metadata: (body)  
     - parameter completion: completion handler to receive the result
     */
    func generateCsrForIdentityProvider(idpId: String, metadata: CsrMetadata, completion: @escaping ((_ result: Swift.Result<Csr, Error>) -> Void)) {
        guard let builder = generateCsrForIdentityProviderWithRequestBuilder(idpId: idpId, metadata: metadata) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func generateCsrForIdentityProviderWithRequestBuilder(idpId: String, metadata: CsrMetadata) -> RequestBuilder<Csr>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/idps/{idpId}/credentials/csrs"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: metadata)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Csr>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Generate New IdP Signing Key Credential
     
     - parameter idpId: (path)  
     - parameter validityYears: (query) expiry of the IdP Key Credential 
     - returns: AnyPublisher<JsonWebKey, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func generateIdentityProviderSigningKey(idpId: String, validityYears: Int) -> AnyPublisher<JsonWebKey, Error> {
        return Future<JsonWebKey, Error>.init { promise in
            guard let builder = self.generateIdentityProviderSigningKeyWithRequestBuilder(idpId: idpId, validityYears: validityYears) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Generate New IdP Signing Key Credential
     
     - parameter idpId: (path)  
     - parameter validityYears: (query) expiry of the IdP Key Credential 
     - parameter completion: completion handler to receive the result
     */
    func generateIdentityProviderSigningKey(idpId: String, validityYears: Int, completion: @escaping ((_ result: Swift.Result<JsonWebKey, Error>) -> Void)) {
        guard let builder = generateIdentityProviderSigningKeyWithRequestBuilder(idpId: idpId, validityYears: validityYears) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func generateIdentityProviderSigningKeyWithRequestBuilder(idpId: String, validityYears: Int) -> RequestBuilder<JsonWebKey>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/idps/{idpId}/credentials/keys/generate"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "validityYears": validityYears.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<JsonWebKey>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter idpId: (path)  
     - parameter csrId: (path)  
     - returns: AnyPublisher<Csr, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getCsrForIdentityProvider(idpId: String, csrId: String) -> AnyPublisher<Csr, Error> {
        return Future<Csr, Error>.init { promise in
            guard let builder = self.getCsrForIdentityProviderWithRequestBuilder(idpId: idpId, csrId: csrId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter idpId: (path)  
     - parameter csrId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func getCsrForIdentityProvider(idpId: String, csrId: String, completion: @escaping ((_ result: Swift.Result<Csr, Error>) -> Void)) {
        guard let builder = getCsrForIdentityProviderWithRequestBuilder(idpId: idpId, csrId: csrId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func getCsrForIdentityProviderWithRequestBuilder(idpId: String, csrId: String) -> RequestBuilder<Csr>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/idps/{idpId}/credentials/csrs/{csrId}"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let csrIdPreEscape = "\(APIHelper.mapValueToPathItem(csrId))"
        let csrIdPostEscape = csrIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{csrId}", with: csrIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Csr>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get Identity Provider
     
     - parameter idpId: (path)  
     - returns: AnyPublisher<IdentityProvider, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getIdentityProvider(idpId: String) -> AnyPublisher<IdentityProvider, Error> {
        return Future<IdentityProvider, Error>.init { promise in
            guard let builder = self.getIdentityProviderWithRequestBuilder(idpId: idpId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Get Identity Provider
     
     - parameter idpId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func getIdentityProvider(idpId: String, completion: @escaping ((_ result: Swift.Result<IdentityProvider, Error>) -> Void)) {
        guard let builder = getIdentityProviderWithRequestBuilder(idpId: idpId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func getIdentityProviderWithRequestBuilder(idpId: String) -> RequestBuilder<IdentityProvider>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/idps/{idpId}"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<IdentityProvider>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter idpId: (path)  
     - parameter userId: (path)  
     - returns: AnyPublisher<IdentityProviderApplicationUser, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getIdentityProviderApplicationUser(idpId: String, userId: String) -> AnyPublisher<IdentityProviderApplicationUser, Error> {
        return Future<IdentityProviderApplicationUser, Error>.init { promise in
            guard let builder = self.getIdentityProviderApplicationUserWithRequestBuilder(idpId: idpId, userId: userId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter idpId: (path)  
     - parameter userId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func getIdentityProviderApplicationUser(idpId: String, userId: String, completion: @escaping ((_ result: Swift.Result<IdentityProviderApplicationUser, Error>) -> Void)) {
        guard let builder = getIdentityProviderApplicationUserWithRequestBuilder(idpId: idpId, userId: userId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func getIdentityProviderApplicationUserWithRequestBuilder(idpId: String, userId: String) -> RequestBuilder<IdentityProviderApplicationUser>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/idps/{idpId}/users/{userId}"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<IdentityProviderApplicationUser>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get Key
     
     - parameter keyId: (path)  
     - returns: AnyPublisher<JsonWebKey, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getIdentityProviderKey(keyId: String) -> AnyPublisher<JsonWebKey, Error> {
        return Future<JsonWebKey, Error>.init { promise in
            guard let builder = self.getIdentityProviderKeyWithRequestBuilder(keyId: keyId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Get Key
     
     - parameter keyId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func getIdentityProviderKey(keyId: String, completion: @escaping ((_ result: Swift.Result<JsonWebKey, Error>) -> Void)) {
        guard let builder = getIdentityProviderKeyWithRequestBuilder(keyId: keyId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func getIdentityProviderKeyWithRequestBuilder(keyId: String) -> RequestBuilder<JsonWebKey>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/idps/credentials/keys/{keyId}"
        let keyIdPreEscape = "\(APIHelper.mapValueToPathItem(keyId))"
        let keyIdPostEscape = keyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{keyId}", with: keyIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<JsonWebKey>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get Signing Key Credential for IdP
     
     - parameter idpId: (path)  
     - parameter keyId: (path)  
     - returns: AnyPublisher<JsonWebKey, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getIdentityProviderSigningKey(idpId: String, keyId: String) -> AnyPublisher<JsonWebKey, Error> {
        return Future<JsonWebKey, Error>.init { promise in
            guard let builder = self.getIdentityProviderSigningKeyWithRequestBuilder(idpId: idpId, keyId: keyId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Get Signing Key Credential for IdP
     
     - parameter idpId: (path)  
     - parameter keyId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func getIdentityProviderSigningKey(idpId: String, keyId: String, completion: @escaping ((_ result: Swift.Result<JsonWebKey, Error>) -> Void)) {
        guard let builder = getIdentityProviderSigningKeyWithRequestBuilder(idpId: idpId, keyId: keyId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func getIdentityProviderSigningKeyWithRequestBuilder(idpId: String, keyId: String) -> RequestBuilder<JsonWebKey>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/idps/{idpId}/credentials/keys/{keyId}"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let keyIdPreEscape = "\(APIHelper.mapValueToPathItem(keyId))"
        let keyIdPostEscape = keyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{keyId}", with: keyIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<JsonWebKey>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Link a user to a Social IdP without a transaction
     
     - parameter idpId: (path)  
     - parameter userId: (path)  
     - parameter userIdentityProviderLinkRequest: (body)  
     - returns: AnyPublisher<IdentityProviderApplicationUser, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func linkUserToIdentityProvider(idpId: String, userId: String, userIdentityProviderLinkRequest: UserIdentityProviderLinkRequest) -> AnyPublisher<IdentityProviderApplicationUser, Error> {
        return Future<IdentityProviderApplicationUser, Error>.init { promise in
            guard let builder = self.linkUserToIdentityProviderWithRequestBuilder(idpId: idpId, userId: userId, userIdentityProviderLinkRequest: userIdentityProviderLinkRequest) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Link a user to a Social IdP without a transaction
     
     - parameter idpId: (path)  
     - parameter userId: (path)  
     - parameter userIdentityProviderLinkRequest: (body)  
     - parameter completion: completion handler to receive the result
     */
    func linkUserToIdentityProvider(idpId: String, userId: String, userIdentityProviderLinkRequest: UserIdentityProviderLinkRequest, completion: @escaping ((_ result: Swift.Result<IdentityProviderApplicationUser, Error>) -> Void)) {
        guard let builder = linkUserToIdentityProviderWithRequestBuilder(idpId: idpId, userId: userId, userIdentityProviderLinkRequest: userIdentityProviderLinkRequest) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func linkUserToIdentityProviderWithRequestBuilder(idpId: String, userId: String, userIdentityProviderLinkRequest: UserIdentityProviderLinkRequest) -> RequestBuilder<IdentityProviderApplicationUser>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/idps/{idpId}/users/{userId}"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: userIdentityProviderLinkRequest)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<IdentityProviderApplicationUser>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     List Certificate Signing Requests for IdP
     
     - parameter idpId: (path)  
     - returns: AnyPublisher<[Csr], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listCsrsForIdentityProvider(idpId: String) -> AnyPublisher<[Csr], Error> {
        return Future<[Csr], Error>.init { promise in
            guard let builder = self.listCsrsForIdentityProviderWithRequestBuilder(idpId: idpId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     List Certificate Signing Requests for IdP
     
     - parameter idpId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func listCsrsForIdentityProvider(idpId: String, completion: @escaping ((_ result: Swift.Result<[Csr], Error>) -> Void)) {
        guard let builder = listCsrsForIdentityProviderWithRequestBuilder(idpId: idpId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listCsrsForIdentityProviderWithRequestBuilder(idpId: String) -> RequestBuilder<[Csr]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/idps/{idpId}/credentials/csrs"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[Csr]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Find Users
     
     - parameter idpId: (path)  
     - returns: AnyPublisher<[IdentityProviderApplicationUser], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listIdentityProviderApplicationUsers(idpId: String) -> AnyPublisher<[IdentityProviderApplicationUser], Error> {
        return Future<[IdentityProviderApplicationUser], Error>.init { promise in
            guard let builder = self.listIdentityProviderApplicationUsersWithRequestBuilder(idpId: idpId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Find Users
     
     - parameter idpId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func listIdentityProviderApplicationUsers(idpId: String, completion: @escaping ((_ result: Swift.Result<[IdentityProviderApplicationUser], Error>) -> Void)) {
        guard let builder = listIdentityProviderApplicationUsersWithRequestBuilder(idpId: idpId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listIdentityProviderApplicationUsersWithRequestBuilder(idpId: String) -> RequestBuilder<[IdentityProviderApplicationUser]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/idps/{idpId}/users"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[IdentityProviderApplicationUser]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     List Keys
     
     - parameter after: (query) Specifies the pagination cursor for the next page of keys (optional)
     - parameter limit: (query) Specifies the number of key results in a page (optional, default to 20)
     - returns: AnyPublisher<[JsonWebKey], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listIdentityProviderKeys(after: String? = nil, limit: Int? = nil) -> AnyPublisher<[JsonWebKey], Error> {
        return Future<[JsonWebKey], Error>.init { promise in
            guard let builder = self.listIdentityProviderKeysWithRequestBuilder(after: after, limit: limit) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     List Keys
     
     - parameter after: (query) Specifies the pagination cursor for the next page of keys (optional)
     - parameter limit: (query) Specifies the number of key results in a page (optional, default to 20)
     - parameter completion: completion handler to receive the result
     */
    func listIdentityProviderKeys(after: String? = nil, limit: Int? = nil, completion: @escaping ((_ result: Swift.Result<[JsonWebKey], Error>) -> Void)) {
        guard let builder = listIdentityProviderKeysWithRequestBuilder(after: after, limit: limit) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listIdentityProviderKeysWithRequestBuilder(after: String? = nil, limit: Int? = nil) -> RequestBuilder<[JsonWebKey]>? {
        guard let api = api else {
            return nil
        }
        let path = "/api/v1/idps/credentials/keys"
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "after": after?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[JsonWebKey]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     List Signing Key Credentials for IdP
     
     - parameter idpId: (path)  
     - returns: AnyPublisher<[JsonWebKey], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listIdentityProviderSigningKeys(idpId: String) -> AnyPublisher<[JsonWebKey], Error> {
        return Future<[JsonWebKey], Error>.init { promise in
            guard let builder = self.listIdentityProviderSigningKeysWithRequestBuilder(idpId: idpId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     List Signing Key Credentials for IdP
     
     - parameter idpId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func listIdentityProviderSigningKeys(idpId: String, completion: @escaping ((_ result: Swift.Result<[JsonWebKey], Error>) -> Void)) {
        guard let builder = listIdentityProviderSigningKeysWithRequestBuilder(idpId: idpId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listIdentityProviderSigningKeysWithRequestBuilder(idpId: String) -> RequestBuilder<[JsonWebKey]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/idps/{idpId}/credentials/keys"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[JsonWebKey]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     List Identity Providers
     
     - parameter q: (query) Searches the name property of IdPs for matching value (optional)
     - parameter after: (query) Specifies the pagination cursor for the next page of IdPs (optional)
     - parameter limit: (query) Specifies the number of IdP results in a page (optional, default to 20)
     - parameter type: (query) Filters IdPs by type (optional)
     - returns: AnyPublisher<[IdentityProvider], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listIdentityProviders(q: String? = nil, after: String? = nil, limit: Int? = nil, type: String? = nil) -> AnyPublisher<[IdentityProvider], Error> {
        return Future<[IdentityProvider], Error>.init { promise in
            guard let builder = self.listIdentityProvidersWithRequestBuilder(q: q, after: after, limit: limit, type: type) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     List Identity Providers
     
     - parameter q: (query) Searches the name property of IdPs for matching value (optional)
     - parameter after: (query) Specifies the pagination cursor for the next page of IdPs (optional)
     - parameter limit: (query) Specifies the number of IdP results in a page (optional, default to 20)
     - parameter type: (query) Filters IdPs by type (optional)
     - parameter completion: completion handler to receive the result
     */
    func listIdentityProviders(q: String? = nil, after: String? = nil, limit: Int? = nil, type: String? = nil, completion: @escaping ((_ result: Swift.Result<[IdentityProvider], Error>) -> Void)) {
        guard let builder = listIdentityProvidersWithRequestBuilder(q: q, after: after, limit: limit, type: type) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listIdentityProvidersWithRequestBuilder(q: String? = nil, after: String? = nil, limit: Int? = nil, type: String? = nil) -> RequestBuilder<[IdentityProvider]>? {
        guard let api = api else {
            return nil
        }
        let path = "/api/v1/idps"
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "q": q?.encodeToJSON(),
            "after": after?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "type": type?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[IdentityProvider]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Social Authentication Token Operation
     
     - parameter idpId: (path)  
     - parameter userId: (path)  
     - returns: AnyPublisher<[SocialAuthToken], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listSocialAuthTokens(idpId: String, userId: String) -> AnyPublisher<[SocialAuthToken], Error> {
        return Future<[SocialAuthToken], Error>.init { promise in
            guard let builder = self.listSocialAuthTokensWithRequestBuilder(idpId: idpId, userId: userId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Social Authentication Token Operation
     
     - parameter idpId: (path)  
     - parameter userId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func listSocialAuthTokens(idpId: String, userId: String, completion: @escaping ((_ result: Swift.Result<[SocialAuthToken], Error>) -> Void)) {
        guard let builder = listSocialAuthTokensWithRequestBuilder(idpId: idpId, userId: userId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listSocialAuthTokensWithRequestBuilder(idpId: String, userId: String) -> RequestBuilder<[SocialAuthToken]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/idps/{idpId}/users/{userId}/credentials/tokens"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[SocialAuthToken]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter idpId: (path)  
     - parameter csrId: (path)  
     - returns: AnyPublisher<JsonWebKey, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func publishCsrForIdentityProvider(idpId: String, csrId: String) -> AnyPublisher<JsonWebKey, Error> {
        return Future<JsonWebKey, Error>.init { promise in
            guard let builder = self.publishCsrForIdentityProviderWithRequestBuilder(idpId: idpId, csrId: csrId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter idpId: (path)  
     - parameter csrId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func publishCsrForIdentityProvider(idpId: String, csrId: String, completion: @escaping ((_ result: Swift.Result<JsonWebKey, Error>) -> Void)) {
        guard let builder = publishCsrForIdentityProviderWithRequestBuilder(idpId: idpId, csrId: csrId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func publishCsrForIdentityProviderWithRequestBuilder(idpId: String, csrId: String) -> RequestBuilder<JsonWebKey>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/idps/{idpId}/credentials/csrs/{csrId}/lifecycle/publish"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let csrIdPreEscape = "\(APIHelper.mapValueToPathItem(csrId))"
        let csrIdPostEscape = csrIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{csrId}", with: csrIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<JsonWebKey>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter idpId: (path)  
     - parameter csrId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func revokeCsrForIdentityProvider(idpId: String, csrId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.revokeCsrForIdentityProviderWithRequestBuilder(idpId: idpId, csrId: csrId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter idpId: (path)  
     - parameter csrId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func revokeCsrForIdentityProvider(idpId: String, csrId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = revokeCsrForIdentityProviderWithRequestBuilder(idpId: idpId, csrId: csrId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func revokeCsrForIdentityProviderWithRequestBuilder(idpId: String, csrId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/idps/{idpId}/credentials/csrs/{csrId}"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let csrIdPreEscape = "\(APIHelper.mapValueToPathItem(csrId))"
        let csrIdPostEscape = csrIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{csrId}", with: csrIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Unlink User from IdP
     
     - parameter idpId: (path)  
     - parameter userId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func unlinkUserFromIdentityProvider(idpId: String, userId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.unlinkUserFromIdentityProviderWithRequestBuilder(idpId: idpId, userId: userId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Unlink User from IdP
     
     - parameter idpId: (path)  
     - parameter userId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func unlinkUserFromIdentityProvider(idpId: String, userId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = unlinkUserFromIdentityProviderWithRequestBuilder(idpId: idpId, userId: userId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func unlinkUserFromIdentityProviderWithRequestBuilder(idpId: String, userId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/idps/{idpId}/users/{userId}"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Update Identity Provider
     
     - parameter idpId: (path)  
     - parameter identityProvider: (body)  
     - returns: AnyPublisher<IdentityProvider, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func updateIdentityProvider(idpId: String, identityProvider: IdentityProvider) -> AnyPublisher<IdentityProvider, Error> {
        return Future<IdentityProvider, Error>.init { promise in
            guard let builder = self.updateIdentityProviderWithRequestBuilder(idpId: idpId, identityProvider: identityProvider) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Update Identity Provider
     
     - parameter idpId: (path)  
     - parameter identityProvider: (body)  
     - parameter completion: completion handler to receive the result
     */
    func updateIdentityProvider(idpId: String, identityProvider: IdentityProvider, completion: @escaping ((_ result: Swift.Result<IdentityProvider, Error>) -> Void)) {
        guard let builder = updateIdentityProviderWithRequestBuilder(idpId: idpId, identityProvider: identityProvider) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func updateIdentityProviderWithRequestBuilder(idpId: String, identityProvider: IdentityProvider) -> RequestBuilder<IdentityProvider>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/idps/{idpId}"
        let idpIdPreEscape = "\(APIHelper.mapValueToPathItem(idpId))"
        let idpIdPostEscape = idpIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{idpId}", with: idpIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: identityProvider)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<IdentityProvider>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "PUT", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

}
}
