//
// ApplicationAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(Combine)
import Combine
#endif
import AnyCodable

extension OktaSdk.API {


public class ApplicationAPI {
    internal weak var api: OktaSdkAPI?

    internal init(api: OktaSdkAPI) {
        self.api = api
    }

    /**
     Activate Application
     
     - parameter appId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func activateApplication(appId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.activateApplicationWithRequestBuilder(appId: appId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Activate Application
     
     - parameter appId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func activateApplication(appId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = activateApplicationWithRequestBuilder(appId: appId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func activateApplicationWithRequestBuilder(appId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/lifecycle/activate"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Assign User to Application for SSO & Provisioning
     
     - parameter appId: (path)  
     - parameter appUser: (body)  
     - returns: AnyPublisher<AppUser, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func assignUserToApplication(appId: String, appUser: AppUser) -> AnyPublisher<AppUser, Error> {
        return Future<AppUser, Error>.init { promise in
            guard let builder = self.assignUserToApplicationWithRequestBuilder(appId: appId, appUser: appUser) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Assign User to Application for SSO & Provisioning
     
     - parameter appId: (path)  
     - parameter appUser: (body)  
     - parameter completion: completion handler to receive the result
     */
    func assignUserToApplication(appId: String, appUser: AppUser, completion: @escaping ((_ result: Swift.Result<AppUser, Error>) -> Void)) {
        guard let builder = assignUserToApplicationWithRequestBuilder(appId: appId, appUser: appUser) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func assignUserToApplicationWithRequestBuilder(appId: String, appUser: AppUser) -> RequestBuilder<AppUser>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/users"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: appUser)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<AppUser>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Clone Application Key Credential
     
     - parameter appId: (path)  
     - parameter keyId: (path)  
     - parameter targetAid: (query) Unique key of the target Application 
     - returns: AnyPublisher<JsonWebKey, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func cloneApplicationKey(appId: String, keyId: String, targetAid: String) -> AnyPublisher<JsonWebKey, Error> {
        return Future<JsonWebKey, Error>.init { promise in
            guard let builder = self.cloneApplicationKeyWithRequestBuilder(appId: appId, keyId: keyId, targetAid: targetAid) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Clone Application Key Credential
     
     - parameter appId: (path)  
     - parameter keyId: (path)  
     - parameter targetAid: (query) Unique key of the target Application 
     - parameter completion: completion handler to receive the result
     */
    func cloneApplicationKey(appId: String, keyId: String, targetAid: String, completion: @escaping ((_ result: Swift.Result<JsonWebKey, Error>) -> Void)) {
        guard let builder = cloneApplicationKeyWithRequestBuilder(appId: appId, keyId: keyId, targetAid: targetAid) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func cloneApplicationKeyWithRequestBuilder(appId: String, keyId: String, targetAid: String) -> RequestBuilder<JsonWebKey>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/credentials/keys/{keyId}/clone"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let keyIdPreEscape = "\(APIHelper.mapValueToPathItem(keyId))"
        let keyIdPostEscape = keyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{keyId}", with: keyIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "targetAid": targetAid.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<JsonWebKey>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Add Application
     
     - parameter application: (body)  
     - parameter activate: (query) Executes activation lifecycle operation when creating the app (optional, default to true)
     - parameter oktaAccessGatewayAgent: (header)  (optional)
     - returns: AnyPublisher<Application, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func createApplication(application: Application, activate: Bool? = nil, oktaAccessGatewayAgent: String? = nil) -> AnyPublisher<Application, Error> {
        return Future<Application, Error>.init { promise in
            guard let builder = self.createApplicationWithRequestBuilder(application: application, activate: activate, oktaAccessGatewayAgent: oktaAccessGatewayAgent) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Add Application
     
     - parameter application: (body)  
     - parameter activate: (query) Executes activation lifecycle operation when creating the app (optional, default to true)
     - parameter oktaAccessGatewayAgent: (header)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func createApplication(application: Application, activate: Bool? = nil, oktaAccessGatewayAgent: String? = nil, completion: @escaping ((_ result: Swift.Result<Application, Error>) -> Void)) {
        guard let builder = createApplicationWithRequestBuilder(application: application, activate: activate, oktaAccessGatewayAgent: oktaAccessGatewayAgent) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func createApplicationWithRequestBuilder(application: Application, activate: Bool? = nil, oktaAccessGatewayAgent: String? = nil) -> RequestBuilder<Application>? {
        guard let api = api else {
            return nil
        }
        let path = "/api/v1/apps"
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: application)

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "activate": activate?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            "OktaAccessGateway-Agent": oktaAccessGatewayAgent?.encodeToJSON(),
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Application>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Assign Group to Application
     
     - parameter appId: (path)  
     - parameter groupId: (path)  
     - parameter applicationGroupAssignment: (body)  (optional)
     - returns: AnyPublisher<ApplicationGroupAssignment, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func createApplicationGroupAssignment(appId: String, groupId: String, applicationGroupAssignment: ApplicationGroupAssignment? = nil) -> AnyPublisher<ApplicationGroupAssignment, Error> {
        return Future<ApplicationGroupAssignment, Error>.init { promise in
            guard let builder = self.createApplicationGroupAssignmentWithRequestBuilder(appId: appId, groupId: groupId, applicationGroupAssignment: applicationGroupAssignment) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Assign Group to Application
     
     - parameter appId: (path)  
     - parameter groupId: (path)  
     - parameter applicationGroupAssignment: (body)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func createApplicationGroupAssignment(appId: String, groupId: String, applicationGroupAssignment: ApplicationGroupAssignment? = nil, completion: @escaping ((_ result: Swift.Result<ApplicationGroupAssignment, Error>) -> Void)) {
        guard let builder = createApplicationGroupAssignmentWithRequestBuilder(appId: appId, groupId: groupId, applicationGroupAssignment: applicationGroupAssignment) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func createApplicationGroupAssignmentWithRequestBuilder(appId: String, groupId: String, applicationGroupAssignment: ApplicationGroupAssignment? = nil) -> RequestBuilder<ApplicationGroupAssignment>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/groups/{groupId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let groupIdPreEscape = "\(APIHelper.mapValueToPathItem(groupId))"
        let groupIdPostEscape = groupIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{groupId}", with: groupIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: applicationGroupAssignment)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<ApplicationGroupAssignment>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "PUT", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Deactivate Application
     
     - parameter appId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func deactivateApplication(appId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.deactivateApplicationWithRequestBuilder(appId: appId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Deactivate Application
     
     - parameter appId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func deactivateApplication(appId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = deactivateApplicationWithRequestBuilder(appId: appId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func deactivateApplicationWithRequestBuilder(appId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/lifecycle/deactivate"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Delete Application
     
     - parameter appId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func deleteApplication(appId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.deleteApplicationWithRequestBuilder(appId: appId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Delete Application
     
     - parameter appId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func deleteApplication(appId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = deleteApplicationWithRequestBuilder(appId: appId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func deleteApplicationWithRequestBuilder(appId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Remove Group from Application
     
     - parameter appId: (path)  
     - parameter groupId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func deleteApplicationGroupAssignment(appId: String, groupId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.deleteApplicationGroupAssignmentWithRequestBuilder(appId: appId, groupId: groupId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Remove Group from Application
     
     - parameter appId: (path)  
     - parameter groupId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func deleteApplicationGroupAssignment(appId: String, groupId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = deleteApplicationGroupAssignmentWithRequestBuilder(appId: appId, groupId: groupId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func deleteApplicationGroupAssignmentWithRequestBuilder(appId: String, groupId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/groups/{groupId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let groupIdPreEscape = "\(APIHelper.mapValueToPathItem(groupId))"
        let groupIdPostEscape = groupIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{groupId}", with: groupIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Remove User from Application
     
     - parameter appId: (path)  
     - parameter userId: (path)  
     - parameter sendEmail: (query)  (optional, default to false)
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func deleteApplicationUser(appId: String, userId: String, sendEmail: Bool? = nil) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.deleteApplicationUserWithRequestBuilder(appId: appId, userId: userId, sendEmail: sendEmail) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Remove User from Application
     
     - parameter appId: (path)  
     - parameter userId: (path)  
     - parameter sendEmail: (query)  (optional, default to false)
     - parameter completion: completion handler to receive the result
     */
    func deleteApplicationUser(appId: String, userId: String, sendEmail: Bool? = nil, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = deleteApplicationUserWithRequestBuilder(appId: appId, userId: userId, sendEmail: sendEmail) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func deleteApplicationUserWithRequestBuilder(appId: String, userId: String, sendEmail: Bool? = nil) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/users/{userId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "sendEmail": sendEmail?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter appId: (path)  
     - parameter validityYears: (query)  (optional)
     - returns: AnyPublisher<JsonWebKey, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func generateApplicationKey(appId: String, validityYears: Int? = nil) -> AnyPublisher<JsonWebKey, Error> {
        return Future<JsonWebKey, Error>.init { promise in
            guard let builder = self.generateApplicationKeyWithRequestBuilder(appId: appId, validityYears: validityYears) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter appId: (path)  
     - parameter validityYears: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func generateApplicationKey(appId: String, validityYears: Int? = nil, completion: @escaping ((_ result: Swift.Result<JsonWebKey, Error>) -> Void)) {
        guard let builder = generateApplicationKeyWithRequestBuilder(appId: appId, validityYears: validityYears) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func generateApplicationKeyWithRequestBuilder(appId: String, validityYears: Int? = nil) -> RequestBuilder<JsonWebKey>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/credentials/keys/generate"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "validityYears": validityYears?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<JsonWebKey>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Generate Certificate Signing Request for Application
     
     - parameter appId: (path)  
     - parameter metadata: (body)  
     - returns: AnyPublisher<Csr, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func generateCsrForApplication(appId: String, metadata: CsrMetadata) -> AnyPublisher<Csr, Error> {
        return Future<Csr, Error>.init { promise in
            guard let builder = self.generateCsrForApplicationWithRequestBuilder(appId: appId, metadata: metadata) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Generate Certificate Signing Request for Application
     
     - parameter appId: (path)  
     - parameter metadata: (body)  
     - parameter completion: completion handler to receive the result
     */
    func generateCsrForApplication(appId: String, metadata: CsrMetadata, completion: @escaping ((_ result: Swift.Result<Csr, Error>) -> Void)) {
        guard let builder = generateCsrForApplicationWithRequestBuilder(appId: appId, metadata: metadata) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func generateCsrForApplicationWithRequestBuilder(appId: String, metadata: CsrMetadata) -> RequestBuilder<Csr>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/credentials/csrs"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: metadata)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Csr>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get Application
     
     - parameter appId: (path)  
     - parameter expand: (query)  (optional)
     - returns: AnyPublisher<Application, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getApplication(appId: String, expand: String? = nil) -> AnyPublisher<Application, Error> {
        return Future<Application, Error>.init { promise in
            guard let builder = self.getApplicationWithRequestBuilder(appId: appId, expand: expand) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Get Application
     
     - parameter appId: (path)  
     - parameter expand: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func getApplication(appId: String, expand: String? = nil, completion: @escaping ((_ result: Swift.Result<Application, Error>) -> Void)) {
        guard let builder = getApplicationWithRequestBuilder(appId: appId, expand: expand) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func getApplicationWithRequestBuilder(appId: String, expand: String? = nil) -> RequestBuilder<Application>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "expand": expand?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Application>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get Assigned Group for Application
     
     - parameter appId: (path)  
     - parameter groupId: (path)  
     - parameter expand: (query)  (optional)
     - returns: AnyPublisher<ApplicationGroupAssignment, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getApplicationGroupAssignment(appId: String, groupId: String, expand: String? = nil) -> AnyPublisher<ApplicationGroupAssignment, Error> {
        return Future<ApplicationGroupAssignment, Error>.init { promise in
            guard let builder = self.getApplicationGroupAssignmentWithRequestBuilder(appId: appId, groupId: groupId, expand: expand) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Get Assigned Group for Application
     
     - parameter appId: (path)  
     - parameter groupId: (path)  
     - parameter expand: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func getApplicationGroupAssignment(appId: String, groupId: String, expand: String? = nil, completion: @escaping ((_ result: Swift.Result<ApplicationGroupAssignment, Error>) -> Void)) {
        guard let builder = getApplicationGroupAssignmentWithRequestBuilder(appId: appId, groupId: groupId, expand: expand) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func getApplicationGroupAssignmentWithRequestBuilder(appId: String, groupId: String, expand: String? = nil) -> RequestBuilder<ApplicationGroupAssignment>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/groups/{groupId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let groupIdPreEscape = "\(APIHelper.mapValueToPathItem(groupId))"
        let groupIdPostEscape = groupIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{groupId}", with: groupIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "expand": expand?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<ApplicationGroupAssignment>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get Key Credential for Application
     
     - parameter appId: (path)  
     - parameter keyId: (path)  
     - returns: AnyPublisher<JsonWebKey, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getApplicationKey(appId: String, keyId: String) -> AnyPublisher<JsonWebKey, Error> {
        return Future<JsonWebKey, Error>.init { promise in
            guard let builder = self.getApplicationKeyWithRequestBuilder(appId: appId, keyId: keyId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Get Key Credential for Application
     
     - parameter appId: (path)  
     - parameter keyId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func getApplicationKey(appId: String, keyId: String, completion: @escaping ((_ result: Swift.Result<JsonWebKey, Error>) -> Void)) {
        guard let builder = getApplicationKeyWithRequestBuilder(appId: appId, keyId: keyId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func getApplicationKeyWithRequestBuilder(appId: String, keyId: String) -> RequestBuilder<JsonWebKey>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/credentials/keys/{keyId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let keyIdPreEscape = "\(APIHelper.mapValueToPathItem(keyId))"
        let keyIdPostEscape = keyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{keyId}", with: keyIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<JsonWebKey>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get Assigned User for Application
     
     - parameter appId: (path)  
     - parameter userId: (path)  
     - parameter expand: (query)  (optional)
     - returns: AnyPublisher<AppUser, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getApplicationUser(appId: String, userId: String, expand: String? = nil) -> AnyPublisher<AppUser, Error> {
        return Future<AppUser, Error>.init { promise in
            guard let builder = self.getApplicationUserWithRequestBuilder(appId: appId, userId: userId, expand: expand) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Get Assigned User for Application
     
     - parameter appId: (path)  
     - parameter userId: (path)  
     - parameter expand: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func getApplicationUser(appId: String, userId: String, expand: String? = nil, completion: @escaping ((_ result: Swift.Result<AppUser, Error>) -> Void)) {
        guard let builder = getApplicationUserWithRequestBuilder(appId: appId, userId: userId, expand: expand) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func getApplicationUserWithRequestBuilder(appId: String, userId: String, expand: String? = nil) -> RequestBuilder<AppUser>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/users/{userId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "expand": expand?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<AppUser>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get Certificate Signing Request
     
     - parameter appId: (path)  
     - parameter csrId: (path)  
     - returns: AnyPublisher<Csr, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getCsrForApplication(appId: String, csrId: String) -> AnyPublisher<Csr, Error> {
        return Future<Csr, Error>.init { promise in
            guard let builder = self.getCsrForApplicationWithRequestBuilder(appId: appId, csrId: csrId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Get Certificate Signing Request
     
     - parameter appId: (path)  
     - parameter csrId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func getCsrForApplication(appId: String, csrId: String, completion: @escaping ((_ result: Swift.Result<Csr, Error>) -> Void)) {
        guard let builder = getCsrForApplicationWithRequestBuilder(appId: appId, csrId: csrId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func getCsrForApplicationWithRequestBuilder(appId: String, csrId: String) -> RequestBuilder<Csr>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/credentials/csrs/{csrId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let csrIdPreEscape = "\(APIHelper.mapValueToPathItem(csrId))"
        let csrIdPostEscape = csrIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{csrId}", with: csrIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Csr>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter appId: (path)  
     - parameter tokenId: (path)  
     - parameter expand: (query)  (optional)
     - returns: AnyPublisher<OAuth2Token, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getOAuth2TokenForApplication(appId: String, tokenId: String, expand: String? = nil) -> AnyPublisher<OAuth2Token, Error> {
        return Future<OAuth2Token, Error>.init { promise in
            guard let builder = self.getOAuth2TokenForApplicationWithRequestBuilder(appId: appId, tokenId: tokenId, expand: expand) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter appId: (path)  
     - parameter tokenId: (path)  
     - parameter expand: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func getOAuth2TokenForApplication(appId: String, tokenId: String, expand: String? = nil, completion: @escaping ((_ result: Swift.Result<OAuth2Token, Error>) -> Void)) {
        guard let builder = getOAuth2TokenForApplicationWithRequestBuilder(appId: appId, tokenId: tokenId, expand: expand) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func getOAuth2TokenForApplicationWithRequestBuilder(appId: String, tokenId: String, expand: String? = nil) -> RequestBuilder<OAuth2Token>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/tokens/{tokenId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let tokenIdPreEscape = "\(APIHelper.mapValueToPathItem(tokenId))"
        let tokenIdPostEscape = tokenIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{tokenId}", with: tokenIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "expand": expand?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<OAuth2Token>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter appId: (path)  
     - parameter grantId: (path)  
     - parameter expand: (query)  (optional)
     - returns: AnyPublisher<OAuth2ScopeConsentGrant, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getScopeConsentGrant(appId: String, grantId: String, expand: String? = nil) -> AnyPublisher<OAuth2ScopeConsentGrant, Error> {
        return Future<OAuth2ScopeConsentGrant, Error>.init { promise in
            guard let builder = self.getScopeConsentGrantWithRequestBuilder(appId: appId, grantId: grantId, expand: expand) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter appId: (path)  
     - parameter grantId: (path)  
     - parameter expand: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func getScopeConsentGrant(appId: String, grantId: String, expand: String? = nil, completion: @escaping ((_ result: Swift.Result<OAuth2ScopeConsentGrant, Error>) -> Void)) {
        guard let builder = getScopeConsentGrantWithRequestBuilder(appId: appId, grantId: grantId, expand: expand) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func getScopeConsentGrantWithRequestBuilder(appId: String, grantId: String, expand: String? = nil) -> RequestBuilder<OAuth2ScopeConsentGrant>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/grants/{grantId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let grantIdPreEscape = "\(APIHelper.mapValueToPathItem(grantId))"
        let grantIdPostEscape = grantIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{grantId}", with: grantIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "expand": expand?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<OAuth2ScopeConsentGrant>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter appId: (path)  
     - parameter oAuth2ScopeConsentGrant: (body)  
     - returns: AnyPublisher<OAuth2ScopeConsentGrant, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func grantConsentToScope(appId: String, oAuth2ScopeConsentGrant: OAuth2ScopeConsentGrant) -> AnyPublisher<OAuth2ScopeConsentGrant, Error> {
        return Future<OAuth2ScopeConsentGrant, Error>.init { promise in
            guard let builder = self.grantConsentToScopeWithRequestBuilder(appId: appId, oAuth2ScopeConsentGrant: oAuth2ScopeConsentGrant) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter appId: (path)  
     - parameter oAuth2ScopeConsentGrant: (body)  
     - parameter completion: completion handler to receive the result
     */
    func grantConsentToScope(appId: String, oAuth2ScopeConsentGrant: OAuth2ScopeConsentGrant, completion: @escaping ((_ result: Swift.Result<OAuth2ScopeConsentGrant, Error>) -> Void)) {
        guard let builder = grantConsentToScopeWithRequestBuilder(appId: appId, oAuth2ScopeConsentGrant: oAuth2ScopeConsentGrant) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func grantConsentToScopeWithRequestBuilder(appId: String, oAuth2ScopeConsentGrant: OAuth2ScopeConsentGrant) -> RequestBuilder<OAuth2ScopeConsentGrant>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/grants"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: oAuth2ScopeConsentGrant)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<OAuth2ScopeConsentGrant>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     List Groups Assigned to Application
     
     - parameter appId: (path)  
     - parameter q: (query)  (optional)
     - parameter after: (query) Specifies the pagination cursor for the next page of assignments (optional)
     - parameter limit: (query) Specifies the number of results for a page (optional, default to -1)
     - parameter expand: (query)  (optional)
     - returns: AnyPublisher<[ApplicationGroupAssignment], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listApplicationGroupAssignments(appId: String, q: String? = nil, after: String? = nil, limit: Int? = nil, expand: String? = nil) -> AnyPublisher<[ApplicationGroupAssignment], Error> {
        return Future<[ApplicationGroupAssignment], Error>.init { promise in
            guard let builder = self.listApplicationGroupAssignmentsWithRequestBuilder(appId: appId, q: q, after: after, limit: limit, expand: expand) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     List Groups Assigned to Application
     
     - parameter appId: (path)  
     - parameter q: (query)  (optional)
     - parameter after: (query) Specifies the pagination cursor for the next page of assignments (optional)
     - parameter limit: (query) Specifies the number of results for a page (optional, default to -1)
     - parameter expand: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func listApplicationGroupAssignments(appId: String, q: String? = nil, after: String? = nil, limit: Int? = nil, expand: String? = nil, completion: @escaping ((_ result: Swift.Result<[ApplicationGroupAssignment], Error>) -> Void)) {
        guard let builder = listApplicationGroupAssignmentsWithRequestBuilder(appId: appId, q: q, after: after, limit: limit, expand: expand) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listApplicationGroupAssignmentsWithRequestBuilder(appId: String, q: String? = nil, after: String? = nil, limit: Int? = nil, expand: String? = nil) -> RequestBuilder<[ApplicationGroupAssignment]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/groups"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "q": q?.encodeToJSON(),
            "after": after?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "expand": expand?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[ApplicationGroupAssignment]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     List Key Credentials for Application
     
     - parameter appId: (path)  
     - returns: AnyPublisher<[JsonWebKey], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listApplicationKeys(appId: String) -> AnyPublisher<[JsonWebKey], Error> {
        return Future<[JsonWebKey], Error>.init { promise in
            guard let builder = self.listApplicationKeysWithRequestBuilder(appId: appId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     List Key Credentials for Application
     
     - parameter appId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func listApplicationKeys(appId: String, completion: @escaping ((_ result: Swift.Result<[JsonWebKey], Error>) -> Void)) {
        guard let builder = listApplicationKeysWithRequestBuilder(appId: appId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listApplicationKeysWithRequestBuilder(appId: String) -> RequestBuilder<[JsonWebKey]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/credentials/keys"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[JsonWebKey]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     List Users Assigned to Application
     
     - parameter appId: (path)  
     - parameter q: (query)  (optional)
     - parameter queryScope: (query)  (optional)
     - parameter after: (query) specifies the pagination cursor for the next page of assignments (optional)
     - parameter limit: (query) specifies the number of results for a page (optional, default to -1)
     - parameter filter: (query)  (optional)
     - parameter expand: (query)  (optional)
     - returns: AnyPublisher<[AppUser], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listApplicationUsers(appId: String, q: String? = nil, queryScope: String? = nil, after: String? = nil, limit: Int? = nil, filter: String? = nil, expand: String? = nil) -> AnyPublisher<[AppUser], Error> {
        return Future<[AppUser], Error>.init { promise in
            guard let builder = self.listApplicationUsersWithRequestBuilder(appId: appId, q: q, queryScope: queryScope, after: after, limit: limit, filter: filter, expand: expand) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     List Users Assigned to Application
     
     - parameter appId: (path)  
     - parameter q: (query)  (optional)
     - parameter queryScope: (query)  (optional)
     - parameter after: (query) specifies the pagination cursor for the next page of assignments (optional)
     - parameter limit: (query) specifies the number of results for a page (optional, default to -1)
     - parameter filter: (query)  (optional)
     - parameter expand: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func listApplicationUsers(appId: String, q: String? = nil, queryScope: String? = nil, after: String? = nil, limit: Int? = nil, filter: String? = nil, expand: String? = nil, completion: @escaping ((_ result: Swift.Result<[AppUser], Error>) -> Void)) {
        guard let builder = listApplicationUsersWithRequestBuilder(appId: appId, q: q, queryScope: queryScope, after: after, limit: limit, filter: filter, expand: expand) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listApplicationUsersWithRequestBuilder(appId: String, q: String? = nil, queryScope: String? = nil, after: String? = nil, limit: Int? = nil, filter: String? = nil, expand: String? = nil) -> RequestBuilder<[AppUser]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/users"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "q": q?.encodeToJSON(),
            "query_scope": queryScope?.encodeToJSON(),
            "after": after?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "filter": filter?.encodeToJSON(),
            "expand": expand?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[AppUser]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     List Applications
     
     - parameter q: (query)  (optional)
     - parameter after: (query) Specifies the pagination cursor for the next page of apps (optional)
     - parameter limit: (query) Specifies the number of results for a page (optional, default to -1)
     - parameter filter: (query) Filters apps by status, user.id, group.id or credentials.signing.kid expression (optional)
     - parameter expand: (query) Traverses users link relationship and optionally embeds Application User resource (optional)
     - parameter includeNonDeleted: (query)  (optional, default to false)
     - returns: AnyPublisher<[Application], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listApplications(q: String? = nil, after: String? = nil, limit: Int? = nil, filter: String? = nil, expand: String? = nil, includeNonDeleted: Bool? = nil) -> AnyPublisher<[Application], Error> {
        return Future<[Application], Error>.init { promise in
            guard let builder = self.listApplicationsWithRequestBuilder(q: q, after: after, limit: limit, filter: filter, expand: expand, includeNonDeleted: includeNonDeleted) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     List Applications
     
     - parameter q: (query)  (optional)
     - parameter after: (query) Specifies the pagination cursor for the next page of apps (optional)
     - parameter limit: (query) Specifies the number of results for a page (optional, default to -1)
     - parameter filter: (query) Filters apps by status, user.id, group.id or credentials.signing.kid expression (optional)
     - parameter expand: (query) Traverses users link relationship and optionally embeds Application User resource (optional)
     - parameter includeNonDeleted: (query)  (optional, default to false)
     - parameter completion: completion handler to receive the result
     */
    func listApplications(q: String? = nil, after: String? = nil, limit: Int? = nil, filter: String? = nil, expand: String? = nil, includeNonDeleted: Bool? = nil, completion: @escaping ((_ result: Swift.Result<[Application], Error>) -> Void)) {
        guard let builder = listApplicationsWithRequestBuilder(q: q, after: after, limit: limit, filter: filter, expand: expand, includeNonDeleted: includeNonDeleted) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listApplicationsWithRequestBuilder(q: String? = nil, after: String? = nil, limit: Int? = nil, filter: String? = nil, expand: String? = nil, includeNonDeleted: Bool? = nil) -> RequestBuilder<[Application]>? {
        guard let api = api else {
            return nil
        }
        let path = "/api/v1/apps"
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "q": q?.encodeToJSON(),
            "after": after?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "filter": filter?.encodeToJSON(),
            "expand": expand?.encodeToJSON(),
            "includeNonDeleted": includeNonDeleted?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[Application]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     List Certificate Signing Requests for Application
     
     - parameter appId: (path)  
     - returns: AnyPublisher<[Csr], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listCsrsForApplication(appId: String) -> AnyPublisher<[Csr], Error> {
        return Future<[Csr], Error>.init { promise in
            guard let builder = self.listCsrsForApplicationWithRequestBuilder(appId: appId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     List Certificate Signing Requests for Application
     
     - parameter appId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func listCsrsForApplication(appId: String, completion: @escaping ((_ result: Swift.Result<[Csr], Error>) -> Void)) {
        guard let builder = listCsrsForApplicationWithRequestBuilder(appId: appId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listCsrsForApplicationWithRequestBuilder(appId: String) -> RequestBuilder<[Csr]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/credentials/csrs"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[Csr]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter appId: (path)  
     - parameter expand: (query)  (optional)
     - parameter after: (query)  (optional)
     - parameter limit: (query)  (optional, default to 20)
     - returns: AnyPublisher<[OAuth2Token], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listOAuth2TokensForApplication(appId: String, expand: String? = nil, after: String? = nil, limit: Int? = nil) -> AnyPublisher<[OAuth2Token], Error> {
        return Future<[OAuth2Token], Error>.init { promise in
            guard let builder = self.listOAuth2TokensForApplicationWithRequestBuilder(appId: appId, expand: expand, after: after, limit: limit) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter appId: (path)  
     - parameter expand: (query)  (optional)
     - parameter after: (query)  (optional)
     - parameter limit: (query)  (optional, default to 20)
     - parameter completion: completion handler to receive the result
     */
    func listOAuth2TokensForApplication(appId: String, expand: String? = nil, after: String? = nil, limit: Int? = nil, completion: @escaping ((_ result: Swift.Result<[OAuth2Token], Error>) -> Void)) {
        guard let builder = listOAuth2TokensForApplicationWithRequestBuilder(appId: appId, expand: expand, after: after, limit: limit) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listOAuth2TokensForApplicationWithRequestBuilder(appId: String, expand: String? = nil, after: String? = nil, limit: Int? = nil) -> RequestBuilder<[OAuth2Token]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/tokens"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "expand": expand?.encodeToJSON(),
            "after": after?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[OAuth2Token]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter appId: (path)  
     - parameter expand: (query)  (optional)
     - returns: AnyPublisher<[OAuth2ScopeConsentGrant], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listScopeConsentGrants(appId: String, expand: String? = nil) -> AnyPublisher<[OAuth2ScopeConsentGrant], Error> {
        return Future<[OAuth2ScopeConsentGrant], Error>.init { promise in
            guard let builder = self.listScopeConsentGrantsWithRequestBuilder(appId: appId, expand: expand) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter appId: (path)  
     - parameter expand: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func listScopeConsentGrants(appId: String, expand: String? = nil, completion: @escaping ((_ result: Swift.Result<[OAuth2ScopeConsentGrant], Error>) -> Void)) {
        guard let builder = listScopeConsentGrantsWithRequestBuilder(appId: appId, expand: expand) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listScopeConsentGrantsWithRequestBuilder(appId: String, expand: String? = nil) -> RequestBuilder<[OAuth2ScopeConsentGrant]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/grants"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "expand": expand?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[OAuth2ScopeConsentGrant]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Publish Certificate Signing Request
     
     - parameter appId: (path)  
     - parameter csrId: (path)  
     - returns: AnyPublisher<JsonWebKey, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func publishCsrFromApplication(appId: String, csrId: String) -> AnyPublisher<JsonWebKey, Error> {
        return Future<JsonWebKey, Error>.init { promise in
            guard let builder = self.publishCsrFromApplicationWithRequestBuilder(appId: appId, csrId: csrId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Publish Certificate Signing Request
     
     - parameter appId: (path)  
     - parameter csrId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func publishCsrFromApplication(appId: String, csrId: String, completion: @escaping ((_ result: Swift.Result<JsonWebKey, Error>) -> Void)) {
        guard let builder = publishCsrFromApplicationWithRequestBuilder(appId: appId, csrId: csrId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func publishCsrFromApplicationWithRequestBuilder(appId: String, csrId: String) -> RequestBuilder<JsonWebKey>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/credentials/csrs/{csrId}/lifecycle/publish"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let csrIdPreEscape = "\(APIHelper.mapValueToPathItem(csrId))"
        let csrIdPostEscape = csrIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{csrId}", with: csrIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<JsonWebKey>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Revoke Certificate Signing Request
     
     - parameter appId: (path)  
     - parameter csrId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func revokeCsrFromApplication(appId: String, csrId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.revokeCsrFromApplicationWithRequestBuilder(appId: appId, csrId: csrId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Revoke Certificate Signing Request
     
     - parameter appId: (path)  
     - parameter csrId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func revokeCsrFromApplication(appId: String, csrId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = revokeCsrFromApplicationWithRequestBuilder(appId: appId, csrId: csrId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func revokeCsrFromApplicationWithRequestBuilder(appId: String, csrId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/credentials/csrs/{csrId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let csrIdPreEscape = "\(APIHelper.mapValueToPathItem(csrId))"
        let csrIdPostEscape = csrIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{csrId}", with: csrIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter appId: (path)  
     - parameter tokenId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func revokeOAuth2TokenForApplication(appId: String, tokenId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.revokeOAuth2TokenForApplicationWithRequestBuilder(appId: appId, tokenId: tokenId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter appId: (path)  
     - parameter tokenId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func revokeOAuth2TokenForApplication(appId: String, tokenId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = revokeOAuth2TokenForApplicationWithRequestBuilder(appId: appId, tokenId: tokenId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func revokeOAuth2TokenForApplicationWithRequestBuilder(appId: String, tokenId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/tokens/{tokenId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let tokenIdPreEscape = "\(APIHelper.mapValueToPathItem(tokenId))"
        let tokenIdPostEscape = tokenIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{tokenId}", with: tokenIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter appId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func revokeOAuth2TokensForApplication(appId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.revokeOAuth2TokensForApplicationWithRequestBuilder(appId: appId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter appId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func revokeOAuth2TokensForApplication(appId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = revokeOAuth2TokensForApplicationWithRequestBuilder(appId: appId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func revokeOAuth2TokensForApplicationWithRequestBuilder(appId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/tokens"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter appId: (path)  
     - parameter grantId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func revokeScopeConsentGrant(appId: String, grantId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.revokeScopeConsentGrantWithRequestBuilder(appId: appId, grantId: grantId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter appId: (path)  
     - parameter grantId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func revokeScopeConsentGrant(appId: String, grantId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = revokeScopeConsentGrantWithRequestBuilder(appId: appId, grantId: grantId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func revokeScopeConsentGrantWithRequestBuilder(appId: String, grantId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/grants/{grantId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let grantIdPreEscape = "\(APIHelper.mapValueToPathItem(grantId))"
        let grantIdPostEscape = grantIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{grantId}", with: grantIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Update Application
     
     - parameter appId: (path)  
     - parameter application: (body)  
     - returns: AnyPublisher<Application, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func updateApplication(appId: String, application: Application) -> AnyPublisher<Application, Error> {
        return Future<Application, Error>.init { promise in
            guard let builder = self.updateApplicationWithRequestBuilder(appId: appId, application: application) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Update Application
     
     - parameter appId: (path)  
     - parameter application: (body)  
     - parameter completion: completion handler to receive the result
     */
    func updateApplication(appId: String, application: Application, completion: @escaping ((_ result: Swift.Result<Application, Error>) -> Void)) {
        guard let builder = updateApplicationWithRequestBuilder(appId: appId, application: application) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func updateApplicationWithRequestBuilder(appId: String, application: Application) -> RequestBuilder<Application>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: application)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Application>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "PUT", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Update Application Profile for Assigned User
     
     - parameter appId: (path)  
     - parameter userId: (path)  
     - parameter appUser: (body)  
     - returns: AnyPublisher<AppUser, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func updateApplicationUser(appId: String, userId: String, appUser: AppUser) -> AnyPublisher<AppUser, Error> {
        return Future<AppUser, Error>.init { promise in
            guard let builder = self.updateApplicationUserWithRequestBuilder(appId: appId, userId: userId, appUser: appUser) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Update Application Profile for Assigned User
     
     - parameter appId: (path)  
     - parameter userId: (path)  
     - parameter appUser: (body)  
     - parameter completion: completion handler to receive the result
     */
    func updateApplicationUser(appId: String, userId: String, appUser: AppUser, completion: @escaping ((_ result: Swift.Result<AppUser, Error>) -> Void)) {
        guard let builder = updateApplicationUserWithRequestBuilder(appId: appId, userId: userId, appUser: appUser) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func updateApplicationUserWithRequestBuilder(appId: String, userId: String, appUser: AppUser) -> RequestBuilder<AppUser>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/apps/{appId}/users/{userId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: appUser)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<AppUser>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

}
}
