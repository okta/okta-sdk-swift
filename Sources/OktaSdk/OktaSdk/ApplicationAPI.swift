//
// ApplicationAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(Combine)
import Combine
#endif
import AnyCodable

extension OktaSdk.API {


public class ApplicationAPI {
    internal weak var api: OktaSdkAPI?
    internal let configuration: OktaClient.Configuration
    internal let queue: DispatchQueue

    internal init(api: OktaSdkAPI) {
        self.api = api
    }

    /**
     Activate Application
     
     - parameter appId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func activateApplication(appId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            activateApplicationWithRequestBuilder(appId: appId).execute(queue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Activate Application
     
     - parameter appId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func activateApplication(appId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        activateApplicationWithRequestBuilder(appId: appId).execute(queue) { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Activate Application
     - POST /api/v1/apps/{appId}/lifecycle/activate
     - Activates an inactive application.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - returns: RequestBuilder<Void> 
     */
    func activateApplicationWithRequestBuilder(appId: String) -> RequestBuilder<Void> {
        var path = "/api/v1/apps/{appId}/lifecycle/activate"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }
        let requestBuilder2: RequestBuilder<Void>.Type = api?.requestBuilderFactory.getNonDecodableBuilder()


        let requestBuilder: RequestBuilder<Void>.Type = client. OktaSdkAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Assign User to Application for SSO & Provisioning
     
     - parameter appId: (path)  
     - parameter appUser: (body)  
     - returns: AnyPublisher<AppUser, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func assignUserToApplication(appId: String, appUser: AppUser) -> AnyPublisher<AppUser, Error> {
        return Future<AppUser, Error>.init { promise in
            assignUserToApplicationWithRequestBuilder(appId: appId, appUser: appUser).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Assign User to Application for SSO & Provisioning
     
     - parameter appId: (path)  
     - parameter appUser: (body)  
     - parameter completion: completion handler to receive the result
     */
    func assignUserToApplication(appId: String, appUser: AppUser, completion: @escaping ((_ result: Swift.Result<AppUser, Error>) -> Void)) {
        assignUserToApplicationWithRequestBuilder(appId: appId, appUser: appUser).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Assign User to Application for SSO & Provisioning
     - POST /api/v1/apps/{appId}/users
     - Assigns an user to an application with [credentials](#application-user-credentials-object) and an app-specific [profile](#application-user-profile-object). Profile mappings defined for the application are first applied before applying any profile properties specified in the request.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter appUser: (body)  
     - returns: RequestBuilder<AppUser> 
     */
    public func assignUserToApplicationWithRequestBuilder(appId: String, appUser: AppUser) -> RequestBuilder<AppUser> {
        var path = "/api/v1/apps/{appId}/users"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: appUser)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<AppUser>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Clone Application Key Credential
     
     - parameter appId: (path)  
     - parameter keyId: (path)  
     - parameter targetAid: (query) Unique key of the target Application 
     - returns: AnyPublisher<JsonWebKey, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func cloneApplicationKey(appId: String, keyId: String, targetAid: String) -> AnyPublisher<JsonWebKey, Error> {
        return Future<JsonWebKey, Error>.init { promise in
            cloneApplicationKeyWithRequestBuilder(appId: appId, keyId: keyId, targetAid: targetAid).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Clone Application Key Credential
     
     - parameter appId: (path)  
     - parameter keyId: (path)  
     - parameter targetAid: (query) Unique key of the target Application 
     - parameter completion: completion handler to receive the result
     */
    func cloneApplicationKey(appId: String, keyId: String, targetAid: String, completion: @escaping ((_ result: Swift.Result<JsonWebKey, Error>) -> Void)) {
        cloneApplicationKeyWithRequestBuilder(appId: appId, keyId: keyId, targetAid: targetAid).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Clone Application Key Credential
     - POST /api/v1/apps/{appId}/credentials/keys/{keyId}/clone
     - Clones a X.509 certificate for an application key credential from a source application to target application.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter keyId: (path)  
     - parameter targetAid: (query) Unique key of the target Application 
     - returns: RequestBuilder<JsonWebKey> 
     */
    public func cloneApplicationKeyWithRequestBuilder(appId: String, keyId: String, targetAid: String) -> RequestBuilder<JsonWebKey> {
        var path = "/api/v1/apps/{appId}/credentials/keys/{keyId}/clone"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let keyIdPreEscape = "\(APIHelper.mapValueToPathItem(keyId))"
        let keyIdPostEscape = keyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{keyId}", with: keyIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "targetAid": targetAid.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<JsonWebKey>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Add Application
     
     - parameter application: (body)  
     - parameter activate: (query) Executes activation lifecycle operation when creating the app (optional, default to true)
     - parameter oktaAccessGatewayAgent: (header)  (optional)
     - returns: AnyPublisher<Application, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func createApplication(application: Application, activate: Bool? = nil, oktaAccessGatewayAgent: String? = nil) -> AnyPublisher<Application, Error> {
        return Future<Application, Error>.init { promise in
            createApplicationWithRequestBuilder(application: application, activate: activate, oktaAccessGatewayAgent: oktaAccessGatewayAgent).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Add Application
     
     - parameter application: (body)  
     - parameter activate: (query) Executes activation lifecycle operation when creating the app (optional, default to true)
     - parameter oktaAccessGatewayAgent: (header)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func createApplication(application: Application, activate: Bool? = nil, oktaAccessGatewayAgent: String? = nil, completion: @escaping ((_ result: Swift.Result<Application, Error>) -> Void)) {
        createApplicationWithRequestBuilder(application: application, activate: activate, oktaAccessGatewayAgent: oktaAccessGatewayAgent).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Add Application
     - POST /api/v1/apps
     - Adds a new application to your Okta organization.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter application: (body)  
     - parameter activate: (query) Executes activation lifecycle operation when creating the app (optional, default to true)
     - parameter oktaAccessGatewayAgent: (header)  (optional)
     - returns: RequestBuilder<Application> 
     */
    public func createApplicationWithRequestBuilder(application: Application, activate: Bool? = nil, oktaAccessGatewayAgent: String? = nil) -> RequestBuilder<Application> {
        let path = "/api/v1/apps"
        let URLString = configuration.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: application)

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "activate": activate?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            "OktaAccessGateway-Agent": oktaAccessGatewayAgent?.encodeToJSON(),
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Application>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Assign Group to Application
     
     - parameter appId: (path)  
     - parameter groupId: (path)  
     - parameter applicationGroupAssignment: (body)  (optional)
     - returns: AnyPublisher<ApplicationGroupAssignment, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func createApplicationGroupAssignment(appId: String, groupId: String, applicationGroupAssignment: ApplicationGroupAssignment? = nil) -> AnyPublisher<ApplicationGroupAssignment, Error> {
        return Future<ApplicationGroupAssignment, Error>.init { promise in
            createApplicationGroupAssignmentWithRequestBuilder(appId: appId, groupId: groupId, applicationGroupAssignment: applicationGroupAssignment).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Assign Group to Application
     
     - parameter appId: (path)  
     - parameter groupId: (path)  
     - parameter applicationGroupAssignment: (body)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func createApplicationGroupAssignment(appId: String, groupId: String, applicationGroupAssignment: ApplicationGroupAssignment? = nil, completion: @escaping ((_ result: Swift.Result<ApplicationGroupAssignment, Error>) -> Void)) {
        createApplicationGroupAssignmentWithRequestBuilder(appId: appId, groupId: groupId, applicationGroupAssignment: applicationGroupAssignment).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Assign Group to Application
     - PUT /api/v1/apps/{appId}/groups/{groupId}
     - Assigns a group to an application
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter groupId: (path)  
     - parameter applicationGroupAssignment: (body)  (optional)
     - returns: RequestBuilder<ApplicationGroupAssignment> 
     */
    public func createApplicationGroupAssignmentWithRequestBuilder(appId: String, groupId: String, applicationGroupAssignment: ApplicationGroupAssignment? = nil) -> RequestBuilder<ApplicationGroupAssignment> {
        var path = "/api/v1/apps/{appId}/groups/{groupId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let groupIdPreEscape = "\(APIHelper.mapValueToPathItem(groupId))"
        let groupIdPostEscape = groupIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{groupId}", with: groupIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: applicationGroupAssignment)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<ApplicationGroupAssignment>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "PUT", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Deactivate Application
     
     - parameter appId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func deactivateApplication(appId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            deactivateApplicationWithRequestBuilder(appId: appId).execute(queue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Deactivate Application
     
     - parameter appId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func deactivateApplication(appId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        deactivateApplicationWithRequestBuilder(appId: appId).execute(queue) { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Deactivate Application
     - POST /api/v1/apps/{appId}/lifecycle/deactivate
     - Deactivates an active application.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - returns: RequestBuilder<Void> 
     */
    public func deactivateApplicationWithRequestBuilder(appId: String) -> RequestBuilder<Void> {
        var path = "/api/v1/apps/{appId}/lifecycle/deactivate"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = OktaSdkAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Delete Application
     
     - parameter appId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func deleteApplication(appId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            deleteApplicationWithRequestBuilder(appId: appId).execute(queue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Delete Application
     
     - parameter appId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func deleteApplication(appId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        deleteApplicationWithRequestBuilder(appId: appId).execute(queue) { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Delete Application
     - DELETE /api/v1/apps/{appId}
     - Removes an inactive application.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - returns: RequestBuilder<Void> 
     */
    public func deleteApplicationWithRequestBuilder(appId: String) -> RequestBuilder<Void> {
        var path = "/api/v1/apps/{appId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = OktaSdkAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Remove Group from Application
     
     - parameter appId: (path)  
     - parameter groupId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func deleteApplicationGroupAssignment(appId: String, groupId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            deleteApplicationGroupAssignmentWithRequestBuilder(appId: appId, groupId: groupId).execute(queue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Remove Group from Application
     
     - parameter appId: (path)  
     - parameter groupId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func deleteApplicationGroupAssignment(appId: String, groupId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        deleteApplicationGroupAssignmentWithRequestBuilder(appId: appId, groupId: groupId).execute(queue) { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Remove Group from Application
     - DELETE /api/v1/apps/{appId}/groups/{groupId}
     - Removes a group assignment from an application.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter groupId: (path)  
     - returns: RequestBuilder<Void> 
     */
    public func deleteApplicationGroupAssignmentWithRequestBuilder(appId: String, groupId: String) -> RequestBuilder<Void> {
        var path = "/api/v1/apps/{appId}/groups/{groupId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let groupIdPreEscape = "\(APIHelper.mapValueToPathItem(groupId))"
        let groupIdPostEscape = groupIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{groupId}", with: groupIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = OktaSdkAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Remove User from Application
     
     - parameter appId: (path)  
     - parameter userId: (path)  
     - parameter sendEmail: (query)  (optional, default to false)
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func deleteApplicationUser(appId: String, userId: String, sendEmail: Bool? = nil) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            deleteApplicationUserWithRequestBuilder(appId: appId, userId: userId, sendEmail: sendEmail).execute(queue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Remove User from Application
     
     - parameter appId: (path)  
     - parameter userId: (path)  
     - parameter sendEmail: (query)  (optional, default to false)
     - parameter completion: completion handler to receive the result
     */
    func deleteApplicationUser(appId: String, userId: String, sendEmail: Bool? = nil, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        deleteApplicationUserWithRequestBuilder(appId: appId, userId: userId, sendEmail: sendEmail).execute(queue) { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Remove User from Application
     - DELETE /api/v1/apps/{appId}/users/{userId}
     - Removes an assignment for a user from an application.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter userId: (path)  
     - parameter sendEmail: (query)  (optional, default to false)
     - returns: RequestBuilder<Void> 
     */
    public func deleteApplicationUserWithRequestBuilder(appId: String, userId: String, sendEmail: Bool? = nil) -> RequestBuilder<Void> {
        var path = "/api/v1/apps/{appId}/users/{userId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "sendEmail": sendEmail?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = OktaSdkAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter appId: (path)  
     - parameter validityYears: (query)  (optional)
     - returns: AnyPublisher<JsonWebKey, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func generateApplicationKey(appId: String, validityYears: Int? = nil) -> AnyPublisher<JsonWebKey, Error> {
        return Future<JsonWebKey, Error>.init { promise in
            generateApplicationKeyWithRequestBuilder(appId: appId, validityYears: validityYears).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter appId: (path)  
     - parameter validityYears: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func generateApplicationKey(appId: String, validityYears: Int? = nil, completion: @escaping ((_ result: Swift.Result<JsonWebKey, Error>) -> Void)) {
        generateApplicationKeyWithRequestBuilder(appId: appId, validityYears: validityYears).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     - POST /api/v1/apps/{appId}/credentials/keys/generate
     - Generates a new X.509 certificate for an application key credential
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter validityYears: (query)  (optional)
     - returns: RequestBuilder<JsonWebKey> 
     */
    public func generateApplicationKeyWithRequestBuilder(appId: String, validityYears: Int? = nil) -> RequestBuilder<JsonWebKey> {
        var path = "/api/v1/apps/{appId}/credentials/keys/generate"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "validityYears": validityYears?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<JsonWebKey>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Generate Certificate Signing Request for Application
     
     - parameter appId: (path)  
     - parameter metadata: (body)  
     - returns: AnyPublisher<Csr, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func generateCsrForApplication(appId: String, metadata: CsrMetadata) -> AnyPublisher<Csr, Error> {
        return Future<Csr, Error>.init { promise in
            generateCsrForApplicationWithRequestBuilder(appId: appId, metadata: metadata).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Generate Certificate Signing Request for Application
     
     - parameter appId: (path)  
     - parameter metadata: (body)  
     - parameter completion: completion handler to receive the result
     */
    func generateCsrForApplication(appId: String, metadata: CsrMetadata, completion: @escaping ((_ result: Swift.Result<Csr, Error>) -> Void)) {
        generateCsrForApplicationWithRequestBuilder(appId: appId, metadata: metadata).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Generate Certificate Signing Request for Application
     - POST /api/v1/apps/{appId}/credentials/csrs
     - Generates a new key pair and returns the Certificate Signing Request for it.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter metadata: (body)  
     - returns: RequestBuilder<Csr> 
     */
    public func generateCsrForApplicationWithRequestBuilder(appId: String, metadata: CsrMetadata) -> RequestBuilder<Csr> {
        var path = "/api/v1/apps/{appId}/credentials/csrs"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: metadata)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Csr>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get Application
     
     - parameter appId: (path)  
     - parameter expand: (query)  (optional)
     - returns: AnyPublisher<Application, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getApplication(appId: String, expand: String? = nil) -> AnyPublisher<Application, Error> {
        return Future<Application, Error>.init { promise in
            getApplicationWithRequestBuilder(appId: appId, expand: expand).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Get Application
     
     - parameter appId: (path)  
     - parameter expand: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func getApplication(appId: String, expand: String? = nil, completion: @escaping ((_ result: Swift.Result<Application, Error>) -> Void)) {
        getApplicationWithRequestBuilder(appId: appId, expand: expand).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Get Application
     - GET /api/v1/apps/{appId}
     - Fetches an application from your Okta organization by `id`.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter expand: (query)  (optional)
     - returns: RequestBuilder<Application> 
     */
    public func getApplicationWithRequestBuilder(appId: String, expand: String? = nil) -> RequestBuilder<Application> {
        var path = "/api/v1/apps/{appId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "expand": expand?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Application>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get Assigned Group for Application
     
     - parameter appId: (path)  
     - parameter groupId: (path)  
     - parameter expand: (query)  (optional)
     - returns: AnyPublisher<ApplicationGroupAssignment, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getApplicationGroupAssignment(appId: String, groupId: String, expand: String? = nil) -> AnyPublisher<ApplicationGroupAssignment, Error> {
        return Future<ApplicationGroupAssignment, Error>.init { promise in
            getApplicationGroupAssignmentWithRequestBuilder(appId: appId, groupId: groupId, expand: expand).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Get Assigned Group for Application
     
     - parameter appId: (path)  
     - parameter groupId: (path)  
     - parameter expand: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func getApplicationGroupAssignment(appId: String, groupId: String, expand: String? = nil, completion: @escaping ((_ result: Swift.Result<ApplicationGroupAssignment, Error>) -> Void)) {
        getApplicationGroupAssignmentWithRequestBuilder(appId: appId, groupId: groupId, expand: expand).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Get Assigned Group for Application
     - GET /api/v1/apps/{appId}/groups/{groupId}
     - Fetches an application group assignment
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter groupId: (path)  
     - parameter expand: (query)  (optional)
     - returns: RequestBuilder<ApplicationGroupAssignment> 
     */
    public func getApplicationGroupAssignmentWithRequestBuilder(appId: String, groupId: String, expand: String? = nil) -> RequestBuilder<ApplicationGroupAssignment> {
        var path = "/api/v1/apps/{appId}/groups/{groupId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let groupIdPreEscape = "\(APIHelper.mapValueToPathItem(groupId))"
        let groupIdPostEscape = groupIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{groupId}", with: groupIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "expand": expand?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<ApplicationGroupAssignment>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get Key Credential for Application
     
     - parameter appId: (path)  
     - parameter keyId: (path)  
     - returns: AnyPublisher<JsonWebKey, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getApplicationKey(appId: String, keyId: String) -> AnyPublisher<JsonWebKey, Error> {
        return Future<JsonWebKey, Error>.init { promise in
            getApplicationKeyWithRequestBuilder(appId: appId, keyId: keyId).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Get Key Credential for Application
     
     - parameter appId: (path)  
     - parameter keyId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func getApplicationKey(appId: String, keyId: String, completion: @escaping ((_ result: Swift.Result<JsonWebKey, Error>) -> Void)) {
        getApplicationKeyWithRequestBuilder(appId: appId, keyId: keyId).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Get Key Credential for Application
     - GET /api/v1/apps/{appId}/credentials/keys/{keyId}
     - Gets a specific application key credential by kid
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter keyId: (path)  
     - returns: RequestBuilder<JsonWebKey> 
     */
    public func getApplicationKeyWithRequestBuilder(appId: String, keyId: String) -> RequestBuilder<JsonWebKey> {
        var path = "/api/v1/apps/{appId}/credentials/keys/{keyId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let keyIdPreEscape = "\(APIHelper.mapValueToPathItem(keyId))"
        let keyIdPostEscape = keyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{keyId}", with: keyIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<JsonWebKey>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get Assigned User for Application
     
     - parameter appId: (path)  
     - parameter userId: (path)  
     - parameter expand: (query)  (optional)
     - returns: AnyPublisher<AppUser, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getApplicationUser(appId: String, userId: String, expand: String? = nil) -> AnyPublisher<AppUser, Error> {
        return Future<AppUser, Error>.init { promise in
            getApplicationUserWithRequestBuilder(appId: appId, userId: userId, expand: expand).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Get Assigned User for Application
     
     - parameter appId: (path)  
     - parameter userId: (path)  
     - parameter expand: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func getApplicationUser(appId: String, userId: String, expand: String? = nil, completion: @escaping ((_ result: Swift.Result<AppUser, Error>) -> Void)) {
        getApplicationUserWithRequestBuilder(appId: appId, userId: userId, expand: expand).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Get Assigned User for Application
     - GET /api/v1/apps/{appId}/users/{userId}
     - Fetches a specific user assignment for application by `id`.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter userId: (path)  
     - parameter expand: (query)  (optional)
     - returns: RequestBuilder<AppUser> 
     */
    public func getApplicationUserWithRequestBuilder(appId: String, userId: String, expand: String? = nil) -> RequestBuilder<AppUser> {
        var path = "/api/v1/apps/{appId}/users/{userId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "expand": expand?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<AppUser>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get Certificate Signing Request
     
     - parameter appId: (path)  
     - parameter csrId: (path)  
     - returns: AnyPublisher<Csr, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getCsrForApplication(appId: String, csrId: String) -> AnyPublisher<Csr, Error> {
        return Future<Csr, Error>.init { promise in
            getCsrForApplicationWithRequestBuilder(appId: appId, csrId: csrId).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Get Certificate Signing Request
     
     - parameter appId: (path)  
     - parameter csrId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func getCsrForApplication(appId: String, csrId: String, completion: @escaping ((_ result: Swift.Result<Csr, Error>) -> Void)) {
        getCsrForApplicationWithRequestBuilder(appId: appId, csrId: csrId).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Get Certificate Signing Request
     - GET /api/v1/apps/{appId}/credentials/csrs/{csrId}
     - Fetches a certificate signing request for the app by `id`.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter csrId: (path)  
     - returns: RequestBuilder<Csr> 
     */
    public func getCsrForApplicationWithRequestBuilder(appId: String, csrId: String) -> RequestBuilder<Csr> {
        var path = "/api/v1/apps/{appId}/credentials/csrs/{csrId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let csrIdPreEscape = "\(APIHelper.mapValueToPathItem(csrId))"
        let csrIdPostEscape = csrIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{csrId}", with: csrIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Csr>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter appId: (path)  
     - parameter tokenId: (path)  
     - parameter expand: (query)  (optional)
     - returns: AnyPublisher<OAuth2Token, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getOAuth2TokenForApplication(appId: String, tokenId: String, expand: String? = nil) -> AnyPublisher<OAuth2Token, Error> {
        return Future<OAuth2Token, Error>.init { promise in
            getOAuth2TokenForApplicationWithRequestBuilder(appId: appId, tokenId: tokenId, expand: expand).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter appId: (path)  
     - parameter tokenId: (path)  
     - parameter expand: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func getOAuth2TokenForApplication(appId: String, tokenId: String, expand: String? = nil, completion: @escaping ((_ result: Swift.Result<OAuth2Token, Error>) -> Void)) {
        getOAuth2TokenForApplicationWithRequestBuilder(appId: appId, tokenId: tokenId, expand: expand).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     - GET /api/v1/apps/{appId}/tokens/{tokenId}
     - Gets a token for the specified application
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter tokenId: (path)  
     - parameter expand: (query)  (optional)
     - returns: RequestBuilder<OAuth2Token> 
     */
    public func getOAuth2TokenForApplicationWithRequestBuilder(appId: String, tokenId: String, expand: String? = nil) -> RequestBuilder<OAuth2Token> {
        var path = "/api/v1/apps/{appId}/tokens/{tokenId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let tokenIdPreEscape = "\(APIHelper.mapValueToPathItem(tokenId))"
        let tokenIdPostEscape = tokenIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{tokenId}", with: tokenIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "expand": expand?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<OAuth2Token>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter appId: (path)  
     - parameter grantId: (path)  
     - parameter expand: (query)  (optional)
     - returns: AnyPublisher<OAuth2ScopeConsentGrant, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getScopeConsentGrant(appId: String, grantId: String, expand: String? = nil) -> AnyPublisher<OAuth2ScopeConsentGrant, Error> {
        return Future<OAuth2ScopeConsentGrant, Error>.init { promise in
            getScopeConsentGrantWithRequestBuilder(appId: appId, grantId: grantId, expand: expand).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter appId: (path)  
     - parameter grantId: (path)  
     - parameter expand: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func getScopeConsentGrant(appId: String, grantId: String, expand: String? = nil, completion: @escaping ((_ result: Swift.Result<OAuth2ScopeConsentGrant, Error>) -> Void)) {
        getScopeConsentGrantWithRequestBuilder(appId: appId, grantId: grantId, expand: expand).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     - GET /api/v1/apps/{appId}/grants/{grantId}
     - Fetches a single scope consent grant for the application
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter grantId: (path)  
     - parameter expand: (query)  (optional)
     - returns: RequestBuilder<OAuth2ScopeConsentGrant> 
     */
    public func getScopeConsentGrantWithRequestBuilder(appId: String, grantId: String, expand: String? = nil) -> RequestBuilder<OAuth2ScopeConsentGrant> {
        var path = "/api/v1/apps/{appId}/grants/{grantId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let grantIdPreEscape = "\(APIHelper.mapValueToPathItem(grantId))"
        let grantIdPostEscape = grantIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{grantId}", with: grantIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "expand": expand?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<OAuth2ScopeConsentGrant>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter appId: (path)  
     - parameter oAuth2ScopeConsentGrant: (body)  
     - returns: AnyPublisher<OAuth2ScopeConsentGrant, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func grantConsentToScope(appId: String, oAuth2ScopeConsentGrant: OAuth2ScopeConsentGrant) -> AnyPublisher<OAuth2ScopeConsentGrant, Error> {
        return Future<OAuth2ScopeConsentGrant, Error>.init { promise in
            grantConsentToScopeWithRequestBuilder(appId: appId, oAuth2ScopeConsentGrant: oAuth2ScopeConsentGrant).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter appId: (path)  
     - parameter oAuth2ScopeConsentGrant: (body)  
     - parameter completion: completion handler to receive the result
     */
    func grantConsentToScope(appId: String, oAuth2ScopeConsentGrant: OAuth2ScopeConsentGrant, completion: @escaping ((_ result: Swift.Result<OAuth2ScopeConsentGrant, Error>) -> Void)) {
        grantConsentToScopeWithRequestBuilder(appId: appId, oAuth2ScopeConsentGrant: oAuth2ScopeConsentGrant).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     - POST /api/v1/apps/{appId}/grants
     - Grants consent for the application to request an OAuth 2.0 Okta scope
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter oAuth2ScopeConsentGrant: (body)  
     - returns: RequestBuilder<OAuth2ScopeConsentGrant> 
     */
    public func grantConsentToScopeWithRequestBuilder(appId: String, oAuth2ScopeConsentGrant: OAuth2ScopeConsentGrant) -> RequestBuilder<OAuth2ScopeConsentGrant> {
        var path = "/api/v1/apps/{appId}/grants"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: oAuth2ScopeConsentGrant)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<OAuth2ScopeConsentGrant>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     List Groups Assigned to Application
     
     - parameter appId: (path)  
     - parameter q: (query)  (optional)
     - parameter after: (query) Specifies the pagination cursor for the next page of assignments (optional)
     - parameter limit: (query) Specifies the number of results for a page (optional, default to -1)
     - parameter expand: (query)  (optional)
     - returns: AnyPublisher<[ApplicationGroupAssignment], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listApplicationGroupAssignments(appId: String, q: String? = nil, after: String? = nil, limit: Int? = nil, expand: String? = nil) -> AnyPublisher<[ApplicationGroupAssignment], Error> {
        return Future<[ApplicationGroupAssignment], Error>.init { promise in
            listApplicationGroupAssignmentsWithRequestBuilder(appId: appId, q: q, after: after, limit: limit, expand: expand).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     List Groups Assigned to Application
     
     - parameter appId: (path)  
     - parameter q: (query)  (optional)
     - parameter after: (query) Specifies the pagination cursor for the next page of assignments (optional)
     - parameter limit: (query) Specifies the number of results for a page (optional, default to -1)
     - parameter expand: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func listApplicationGroupAssignments(appId: String, q: String? = nil, after: String? = nil, limit: Int? = nil, expand: String? = nil, completion: @escaping ((_ result: Swift.Result<[ApplicationGroupAssignment], Error>) -> Void)) {
        listApplicationGroupAssignmentsWithRequestBuilder(appId: appId, q: q, after: after, limit: limit, expand: expand).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     List Groups Assigned to Application
     - GET /api/v1/apps/{appId}/groups
     - Enumerates group assignments for an application.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter q: (query)  (optional)
     - parameter after: (query) Specifies the pagination cursor for the next page of assignments (optional)
     - parameter limit: (query) Specifies the number of results for a page (optional, default to -1)
     - parameter expand: (query)  (optional)
     - returns: RequestBuilder<[ApplicationGroupAssignment]> 
     */
    public func listApplicationGroupAssignmentsWithRequestBuilder(appId: String, q: String? = nil, after: String? = nil, limit: Int? = nil, expand: String? = nil) -> RequestBuilder<[ApplicationGroupAssignment]> {
        var path = "/api/v1/apps/{appId}/groups"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "q": q?.encodeToJSON(),
            "after": after?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "expand": expand?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[ApplicationGroupAssignment]>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     List Key Credentials for Application
     
     - parameter appId: (path)  
     - returns: AnyPublisher<[JsonWebKey], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listApplicationKeys(appId: String) -> AnyPublisher<[JsonWebKey], Error> {
        return Future<[JsonWebKey], Error>.init { promise in
            listApplicationKeysWithRequestBuilder(appId: appId).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     List Key Credentials for Application
     
     - parameter appId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func listApplicationKeys(appId: String, completion: @escaping ((_ result: Swift.Result<[JsonWebKey], Error>) -> Void)) {
        listApplicationKeysWithRequestBuilder(appId: appId).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     List Key Credentials for Application
     - GET /api/v1/apps/{appId}/credentials/keys
     - Enumerates key credentials for an application
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - returns: RequestBuilder<[JsonWebKey]> 
     */
    public func listApplicationKeysWithRequestBuilder(appId: String) -> RequestBuilder<[JsonWebKey]> {
        var path = "/api/v1/apps/{appId}/credentials/keys"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[JsonWebKey]>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     List Users Assigned to Application
     
     - parameter appId: (path)  
     - parameter q: (query)  (optional)
     - parameter queryScope: (query)  (optional)
     - parameter after: (query) specifies the pagination cursor for the next page of assignments (optional)
     - parameter limit: (query) specifies the number of results for a page (optional, default to -1)
     - parameter filter: (query)  (optional)
     - parameter expand: (query)  (optional)
     - returns: AnyPublisher<[AppUser], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listApplicationUsers(appId: String, q: String? = nil, queryScope: String? = nil, after: String? = nil, limit: Int? = nil, filter: String? = nil, expand: String? = nil) -> AnyPublisher<[AppUser], Error> {
        return Future<[AppUser], Error>.init { promise in
            listApplicationUsersWithRequestBuilder(appId: appId, q: q, queryScope: queryScope, after: after, limit: limit, filter: filter, expand: expand).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     List Users Assigned to Application
     
     - parameter appId: (path)  
     - parameter q: (query)  (optional)
     - parameter queryScope: (query)  (optional)
     - parameter after: (query) specifies the pagination cursor for the next page of assignments (optional)
     - parameter limit: (query) specifies the number of results for a page (optional, default to -1)
     - parameter filter: (query)  (optional)
     - parameter expand: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func listApplicationUsers(appId: String, q: String? = nil, queryScope: String? = nil, after: String? = nil, limit: Int? = nil, filter: String? = nil, expand: String? = nil, completion: @escaping ((_ result: Swift.Result<[AppUser], Error>) -> Void)) {
        listApplicationUsersWithRequestBuilder(appId: appId, q: q, queryScope: queryScope, after: after, limit: limit, filter: filter, expand: expand).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     List Users Assigned to Application
     - GET /api/v1/apps/{appId}/users
     - Enumerates all assigned [application users](#application-user-model) for an application.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter q: (query)  (optional)
     - parameter queryScope: (query)  (optional)
     - parameter after: (query) specifies the pagination cursor for the next page of assignments (optional)
     - parameter limit: (query) specifies the number of results for a page (optional, default to -1)
     - parameter filter: (query)  (optional)
     - parameter expand: (query)  (optional)
     - returns: RequestBuilder<[AppUser]> 
     */
    public func listApplicationUsersWithRequestBuilder(appId: String, q: String? = nil, queryScope: String? = nil, after: String? = nil, limit: Int? = nil, filter: String? = nil, expand: String? = nil) -> RequestBuilder<[AppUser]> {
        var path = "/api/v1/apps/{appId}/users"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "q": q?.encodeToJSON(),
            "query_scope": queryScope?.encodeToJSON(),
            "after": after?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "filter": filter?.encodeToJSON(),
            "expand": expand?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[AppUser]>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     List Applications
     
     - parameter q: (query)  (optional)
     - parameter after: (query) Specifies the pagination cursor for the next page of apps (optional)
     - parameter limit: (query) Specifies the number of results for a page (optional, default to -1)
     - parameter filter: (query) Filters apps by status, user.id, group.id or credentials.signing.kid expression (optional)
     - parameter expand: (query) Traverses users link relationship and optionally embeds Application User resource (optional)
     - parameter includeNonDeleted: (query)  (optional, default to false)
     - returns: AnyPublisher<[Application], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listApplications(q: String? = nil, after: String? = nil, limit: Int? = nil, filter: String? = nil, expand: String? = nil, includeNonDeleted: Bool? = nil) -> AnyPublisher<[Application], Error> {
        return Future<[Application], Error>.init { promise in
            listApplicationsWithRequestBuilder(q: q, after: after, limit: limit, filter: filter, expand: expand, includeNonDeleted: includeNonDeleted).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     List Applications
     
     - parameter q: (query)  (optional)
     - parameter after: (query) Specifies the pagination cursor for the next page of apps (optional)
     - parameter limit: (query) Specifies the number of results for a page (optional, default to -1)
     - parameter filter: (query) Filters apps by status, user.id, group.id or credentials.signing.kid expression (optional)
     - parameter expand: (query) Traverses users link relationship and optionally embeds Application User resource (optional)
     - parameter includeNonDeleted: (query)  (optional, default to false)
     - parameter completion: completion handler to receive the result
     */
    func listApplications(q: String? = nil, after: String? = nil, limit: Int? = nil, filter: String? = nil, expand: String? = nil, includeNonDeleted: Bool? = nil, completion: @escaping ((_ result: Swift.Result<[Application], Error>) -> Void)) {
        listApplicationsWithRequestBuilder(q: q, after: after, limit: limit, filter: filter, expand: expand, includeNonDeleted: includeNonDeleted).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     List Applications
     - GET /api/v1/apps
     - Enumerates apps added to your organization with pagination. A subset of apps can be returned that match a supported filter expression or query.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter q: (query)  (optional)
     - parameter after: (query) Specifies the pagination cursor for the next page of apps (optional)
     - parameter limit: (query) Specifies the number of results for a page (optional, default to -1)
     - parameter filter: (query) Filters apps by status, user.id, group.id or credentials.signing.kid expression (optional)
     - parameter expand: (query) Traverses users link relationship and optionally embeds Application User resource (optional)
     - parameter includeNonDeleted: (query)  (optional, default to false)
     - returns: RequestBuilder<[Application]> 
     */
    public func listApplicationsWithRequestBuilder(q: String? = nil, after: String? = nil, limit: Int? = nil, filter: String? = nil, expand: String? = nil, includeNonDeleted: Bool? = nil) -> RequestBuilder<[Application]> {
        let path = "/api/v1/apps"
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "q": q?.encodeToJSON(),
            "after": after?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "filter": filter?.encodeToJSON(),
            "expand": expand?.encodeToJSON(),
            "includeNonDeleted": includeNonDeleted?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[Application]>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     List Certificate Signing Requests for Application
     
     - parameter appId: (path)  
     - returns: AnyPublisher<[Csr], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listCsrsForApplication(appId: String) -> AnyPublisher<[Csr], Error> {
        return Future<[Csr], Error>.init { promise in
            listCsrsForApplicationWithRequestBuilder(appId: appId).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     List Certificate Signing Requests for Application
     
     - parameter appId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func listCsrsForApplication(appId: String, completion: @escaping ((_ result: Swift.Result<[Csr], Error>) -> Void)) {
        listCsrsForApplicationWithRequestBuilder(appId: appId).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     List Certificate Signing Requests for Application
     - GET /api/v1/apps/{appId}/credentials/csrs
     - Enumerates Certificate Signing Requests for an application
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - returns: RequestBuilder<[Csr]> 
     */
    public func listCsrsForApplicationWithRequestBuilder(appId: String) -> RequestBuilder<[Csr]> {
        var path = "/api/v1/apps/{appId}/credentials/csrs"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[Csr]>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter appId: (path)  
     - parameter expand: (query)  (optional)
     - parameter after: (query)  (optional)
     - parameter limit: (query)  (optional, default to 20)
     - returns: AnyPublisher<[OAuth2Token], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listOAuth2TokensForApplication(appId: String, expand: String? = nil, after: String? = nil, limit: Int? = nil) -> AnyPublisher<[OAuth2Token], Error> {
        return Future<[OAuth2Token], Error>.init { promise in
            listOAuth2TokensForApplicationWithRequestBuilder(appId: appId, expand: expand, after: after, limit: limit).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter appId: (path)  
     - parameter expand: (query)  (optional)
     - parameter after: (query)  (optional)
     - parameter limit: (query)  (optional, default to 20)
     - parameter completion: completion handler to receive the result
     */
    func listOAuth2TokensForApplication(appId: String, expand: String? = nil, after: String? = nil, limit: Int? = nil, completion: @escaping ((_ result: Swift.Result<[OAuth2Token], Error>) -> Void)) {
        listOAuth2TokensForApplicationWithRequestBuilder(appId: appId, expand: expand, after: after, limit: limit).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     - GET /api/v1/apps/{appId}/tokens
     - Lists all tokens for the application
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter expand: (query)  (optional)
     - parameter after: (query)  (optional)
     - parameter limit: (query)  (optional, default to 20)
     - returns: RequestBuilder<[OAuth2Token]> 
     */
    public func listOAuth2TokensForApplicationWithRequestBuilder(appId: String, expand: String? = nil, after: String? = nil, limit: Int? = nil) -> RequestBuilder<[OAuth2Token]> {
        var path = "/api/v1/apps/{appId}/tokens"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "expand": expand?.encodeToJSON(),
            "after": after?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[OAuth2Token]>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter appId: (path)  
     - parameter expand: (query)  (optional)
     - returns: AnyPublisher<[OAuth2ScopeConsentGrant], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listScopeConsentGrants(appId: String, expand: String? = nil) -> AnyPublisher<[OAuth2ScopeConsentGrant], Error> {
        return Future<[OAuth2ScopeConsentGrant], Error>.init { promise in
            listScopeConsentGrantsWithRequestBuilder(appId: appId, expand: expand).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter appId: (path)  
     - parameter expand: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func listScopeConsentGrants(appId: String, expand: String? = nil, completion: @escaping ((_ result: Swift.Result<[OAuth2ScopeConsentGrant], Error>) -> Void)) {
        listScopeConsentGrantsWithRequestBuilder(appId: appId, expand: expand).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     - GET /api/v1/apps/{appId}/grants
     - Lists all scope consent grants for the application
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter expand: (query)  (optional)
     - returns: RequestBuilder<[OAuth2ScopeConsentGrant]> 
     */
    public func listScopeConsentGrantsWithRequestBuilder(appId: String, expand: String? = nil) -> RequestBuilder<[OAuth2ScopeConsentGrant]> {
        var path = "/api/v1/apps/{appId}/grants"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "expand": expand?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[OAuth2ScopeConsentGrant]>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Publish Certificate Signing Request
     
     - parameter appId: (path)  
     - parameter csrId: (path)  
     - returns: AnyPublisher<JsonWebKey, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func publishCsrFromApplication(appId: String, csrId: String) -> AnyPublisher<JsonWebKey, Error> {
        return Future<JsonWebKey, Error>.init { promise in
            publishCsrFromApplicationWithRequestBuilder(appId: appId, csrId: csrId).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Publish Certificate Signing Request
     
     - parameter appId: (path)  
     - parameter csrId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func publishCsrFromApplication(appId: String, csrId: String, completion: @escaping ((_ result: Swift.Result<JsonWebKey, Error>) -> Void)) {
        publishCsrFromApplicationWithRequestBuilder(appId: appId, csrId: csrId).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Publish Certificate Signing Request
     - POST /api/v1/apps/{appId}/credentials/csrs/{csrId}/lifecycle/publish
     - Updates a certificate signing request for the app with a signed X.509 certificate and adds it into the application key credentials
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter csrId: (path)  
     - returns: RequestBuilder<JsonWebKey> 
     */
    public func publishCsrFromApplicationWithRequestBuilder(appId: String, csrId: String) -> RequestBuilder<JsonWebKey> {
        var path = "/api/v1/apps/{appId}/credentials/csrs/{csrId}/lifecycle/publish"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let csrIdPreEscape = "\(APIHelper.mapValueToPathItem(csrId))"
        let csrIdPostEscape = csrIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{csrId}", with: csrIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<JsonWebKey>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Revoke Certificate Signing Request
     
     - parameter appId: (path)  
     - parameter csrId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func revokeCsrFromApplication(appId: String, csrId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            revokeCsrFromApplicationWithRequestBuilder(appId: appId, csrId: csrId).execute(queue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Revoke Certificate Signing Request
     
     - parameter appId: (path)  
     - parameter csrId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func revokeCsrFromApplication(appId: String, csrId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        revokeCsrFromApplicationWithRequestBuilder(appId: appId, csrId: csrId).execute(queue) { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Revoke Certificate Signing Request
     - DELETE /api/v1/apps/{appId}/credentials/csrs/{csrId}
     - Revokes a certificate signing request and deletes the key pair from the application.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter csrId: (path)  
     - returns: RequestBuilder<Void> 
     */
    public func revokeCsrFromApplicationWithRequestBuilder(appId: String, csrId: String) -> RequestBuilder<Void> {
        var path = "/api/v1/apps/{appId}/credentials/csrs/{csrId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let csrIdPreEscape = "\(APIHelper.mapValueToPathItem(csrId))"
        let csrIdPostEscape = csrIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{csrId}", with: csrIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = OktaSdkAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter appId: (path)  
     - parameter tokenId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func revokeOAuth2TokenForApplication(appId: String, tokenId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            revokeOAuth2TokenForApplicationWithRequestBuilder(appId: appId, tokenId: tokenId).execute(queue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter appId: (path)  
     - parameter tokenId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func revokeOAuth2TokenForApplication(appId: String, tokenId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        revokeOAuth2TokenForApplicationWithRequestBuilder(appId: appId, tokenId: tokenId).execute(queue) { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     - DELETE /api/v1/apps/{appId}/tokens/{tokenId}
     - Revokes the specified token for the specified application
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter tokenId: (path)  
     - returns: RequestBuilder<Void> 
     */
    public func revokeOAuth2TokenForApplicationWithRequestBuilder(appId: String, tokenId: String) -> RequestBuilder<Void> {
        var path = "/api/v1/apps/{appId}/tokens/{tokenId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let tokenIdPreEscape = "\(APIHelper.mapValueToPathItem(tokenId))"
        let tokenIdPostEscape = tokenIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{tokenId}", with: tokenIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = OktaSdkAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter appId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func revokeOAuth2TokensForApplication(appId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            revokeOAuth2TokensForApplicationWithRequestBuilder(appId: appId).execute(queue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter appId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func revokeOAuth2TokensForApplication(appId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        revokeOAuth2TokensForApplicationWithRequestBuilder(appId: appId).execute(queue) { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     - DELETE /api/v1/apps/{appId}/tokens
     - Revokes all tokens for the specified application
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - returns: RequestBuilder<Void> 
     */
    public func revokeOAuth2TokensForApplicationWithRequestBuilder(appId: String) -> RequestBuilder<Void> {
        var path = "/api/v1/apps/{appId}/tokens"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = OktaSdkAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter appId: (path)  
     - parameter grantId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func revokeScopeConsentGrant(appId: String, grantId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            revokeScopeConsentGrantWithRequestBuilder(appId: appId, grantId: grantId).execute(queue) { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter appId: (path)  
     - parameter grantId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func revokeScopeConsentGrant(appId: String, grantId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        revokeScopeConsentGrantWithRequestBuilder(appId: appId, grantId: grantId).execute(queue) { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     - DELETE /api/v1/apps/{appId}/grants/{grantId}
     - Revokes permission for the application to request the given scope
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter grantId: (path)  
     - returns: RequestBuilder<Void> 
     */
    public func revokeScopeConsentGrantWithRequestBuilder(appId: String, grantId: String) -> RequestBuilder<Void> {
        var path = "/api/v1/apps/{appId}/grants/{grantId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let grantIdPreEscape = "\(APIHelper.mapValueToPathItem(grantId))"
        let grantIdPostEscape = grantIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{grantId}", with: grantIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = OktaSdkAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Update Application
     
     - parameter appId: (path)  
     - parameter application: (body)  
     - returns: AnyPublisher<Application, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func updateApplication(appId: String, application: Application) -> AnyPublisher<Application, Error> {
        return Future<Application, Error>.init { promise in
            updateApplicationWithRequestBuilder(appId: appId, application: application).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Update Application
     
     - parameter appId: (path)  
     - parameter application: (body)  
     - parameter completion: completion handler to receive the result
     */
    func updateApplication(appId: String, application: Application, completion: @escaping ((_ result: Swift.Result<Application, Error>) -> Void)) {
        updateApplicationWithRequestBuilder(appId: appId, application: application).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Update Application
     - PUT /api/v1/apps/{appId}
     - Updates an application in your organization.
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter application: (body)  
     - returns: RequestBuilder<Application> 
     */
    public func updateApplicationWithRequestBuilder(appId: String, application: Application) -> RequestBuilder<Application> {
        var path = "/api/v1/apps/{appId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: application)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Application>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "PUT", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Update Application Profile for Assigned User
     
     - parameter appId: (path)  
     - parameter userId: (path)  
     - parameter appUser: (body)  
     - returns: AnyPublisher<AppUser, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func updateApplicationUser(appId: String, userId: String, appUser: AppUser) -> AnyPublisher<AppUser, Error> {
        return Future<AppUser, Error>.init { promise in
            updateApplicationUserWithRequestBuilder(appId: appId, userId: userId, appUser: appUser).execute(queue) { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Update Application Profile for Assigned User
     
     - parameter appId: (path)  
     - parameter userId: (path)  
     - parameter appUser: (body)  
     - parameter completion: completion handler to receive the result
     */
    func updateApplicationUser(appId: String, userId: String, appUser: AppUser, completion: @escaping ((_ result: Swift.Result<AppUser, Error>) -> Void)) {
        updateApplicationUserWithRequestBuilder(appId: appId, userId: userId, appUser: appUser).execute(queue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    /**
     Update Application Profile for Assigned User
     - POST /api/v1/apps/{appId}/users/{userId}
     - Updates a user's profile for an application
     - API Key:
       - type: apiKey Authorization 
       - name: api_token
     - parameter appId: (path)  
     - parameter userId: (path)  
     - parameter appUser: (body)  
     - returns: RequestBuilder<AppUser> 
     */
    public func updateApplicationUserWithRequestBuilder(appId: String, userId: String, appUser: AppUser) -> RequestBuilder<AppUser> {
        var path = "/api/v1/apps/{appId}/users/{userId}"
        let appIdPreEscape = "\(APIHelper.mapValueToPathItem(appId))"
        let appIdPostEscape = appIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appId}", with: appIdPostEscape, options: .literal, range: nil)
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = configuration.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: appUser)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(configuration.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<AppUser>.Type = OktaSdkAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

}
}
