//
// UserAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(Combine)
import Combine
#endif
import AnyCodable

extension OktaSdk.API {


public class UserAPI {
    internal weak var api: OktaSdkAPI?

    internal init(api: OktaSdkAPI) {
        self.api = api
    }

    /**
     Activate User
     
     - parameter userId: (path)  
     - parameter sendEmail: (query) Sends an activation email to the user if true 
     - returns: AnyPublisher<UserActivationToken, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func activateUser(userId: String, sendEmail: Bool) -> AnyPublisher<UserActivationToken, Error> {
        return Future<UserActivationToken, Error>.init { promise in
            guard let builder = self.activateUserWithRequestBuilder(userId: userId, sendEmail: sendEmail) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Activate User
     
     - parameter userId: (path)  
     - parameter sendEmail: (query) Sends an activation email to the user if true 
     - parameter completion: completion handler to receive the result
     */
    func activateUser(userId: String, sendEmail: Bool, completion: @escaping ((_ result: Swift.Result<UserActivationToken, Error>) -> Void)) {
        guard let builder = activateUserWithRequestBuilder(userId: userId, sendEmail: sendEmail) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func activateUserWithRequestBuilder(userId: String, sendEmail: Bool) -> RequestBuilder<UserActivationToken>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/lifecycle/activate"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "sendEmail": sendEmail.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<UserActivationToken>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter roleId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func addAllAppsAsTargetToRole(userId: String, roleId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.addAllAppsAsTargetToRoleWithRequestBuilder(userId: userId, roleId: roleId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter roleId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func addAllAppsAsTargetToRole(userId: String, roleId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = addAllAppsAsTargetToRoleWithRequestBuilder(userId: userId, roleId: roleId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func addAllAppsAsTargetToRoleWithRequestBuilder(userId: String, roleId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/roles/{roleId}/targets/catalog/apps"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let roleIdPreEscape = "\(APIHelper.mapValueToPathItem(roleId))"
        let roleIdPostEscape = roleIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{roleId}", with: roleIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "PUT", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter roleId: (path)  
     - parameter appName: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func addApplicationTargetToAdminRoleForUser(userId: String, roleId: String, appName: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.addApplicationTargetToAdminRoleForUserWithRequestBuilder(userId: userId, roleId: roleId, appName: appName) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter roleId: (path)  
     - parameter appName: (path)  
     - parameter completion: completion handler to receive the result
     */
    func addApplicationTargetToAdminRoleForUser(userId: String, roleId: String, appName: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = addApplicationTargetToAdminRoleForUserWithRequestBuilder(userId: userId, roleId: roleId, appName: appName) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func addApplicationTargetToAdminRoleForUserWithRequestBuilder(userId: String, roleId: String, appName: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/roles/{roleId}/targets/catalog/apps/{appName}"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let roleIdPreEscape = "\(APIHelper.mapValueToPathItem(roleId))"
        let roleIdPostEscape = roleIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{roleId}", with: roleIdPostEscape, options: .literal, range: nil)
        let appNamePreEscape = "\(APIHelper.mapValueToPathItem(appName))"
        let appNamePostEscape = appNamePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appName}", with: appNamePostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "PUT", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Add App Instance Target to App Administrator Role given to a User
     
     - parameter userId: (path)  
     - parameter roleId: (path)  
     - parameter appName: (path)  
     - parameter applicationId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func addApplicationTargetToAppAdminRoleForUser(userId: String, roleId: String, appName: String, applicationId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.addApplicationTargetToAppAdminRoleForUserWithRequestBuilder(userId: userId, roleId: roleId, appName: appName, applicationId: applicationId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Add App Instance Target to App Administrator Role given to a User
     
     - parameter userId: (path)  
     - parameter roleId: (path)  
     - parameter appName: (path)  
     - parameter applicationId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func addApplicationTargetToAppAdminRoleForUser(userId: String, roleId: String, appName: String, applicationId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = addApplicationTargetToAppAdminRoleForUserWithRequestBuilder(userId: userId, roleId: roleId, appName: appName, applicationId: applicationId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func addApplicationTargetToAppAdminRoleForUserWithRequestBuilder(userId: String, roleId: String, appName: String, applicationId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/roles/{roleId}/targets/catalog/apps/{appName}/{applicationId}"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let roleIdPreEscape = "\(APIHelper.mapValueToPathItem(roleId))"
        let roleIdPostEscape = roleIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{roleId}", with: roleIdPostEscape, options: .literal, range: nil)
        let appNamePreEscape = "\(APIHelper.mapValueToPathItem(appName))"
        let appNamePostEscape = appNamePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appName}", with: appNamePostEscape, options: .literal, range: nil)
        let applicationIdPreEscape = "\(APIHelper.mapValueToPathItem(applicationId))"
        let applicationIdPostEscape = applicationIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{applicationId}", with: applicationIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "PUT", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter roleId: (path)  
     - parameter groupId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func addGroupTargetToRole(userId: String, roleId: String, groupId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.addGroupTargetToRoleWithRequestBuilder(userId: userId, roleId: roleId, groupId: groupId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter roleId: (path)  
     - parameter groupId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func addGroupTargetToRole(userId: String, roleId: String, groupId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = addGroupTargetToRoleWithRequestBuilder(userId: userId, roleId: roleId, groupId: groupId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func addGroupTargetToRoleWithRequestBuilder(userId: String, roleId: String, groupId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/roles/{roleId}/targets/groups/{groupId}"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let roleIdPreEscape = "\(APIHelper.mapValueToPathItem(roleId))"
        let roleIdPostEscape = roleIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{roleId}", with: roleIdPostEscape, options: .literal, range: nil)
        let groupIdPreEscape = "\(APIHelper.mapValueToPathItem(groupId))"
        let groupIdPostEscape = groupIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{groupId}", with: groupIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "PUT", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter assignRoleRequest: (body)  
     - parameter disableNotifications: (query)  (optional)
     - returns: AnyPublisher<Role, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func assignRoleToUser(userId: String, assignRoleRequest: AssignRoleRequest, disableNotifications: String? = nil) -> AnyPublisher<Role, Error> {
        return Future<Role, Error>.init { promise in
            guard let builder = self.assignRoleToUserWithRequestBuilder(userId: userId, assignRoleRequest: assignRoleRequest, disableNotifications: disableNotifications) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter assignRoleRequest: (body)  
     - parameter disableNotifications: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func assignRoleToUser(userId: String, assignRoleRequest: AssignRoleRequest, disableNotifications: String? = nil, completion: @escaping ((_ result: Swift.Result<Role, Error>) -> Void)) {
        guard let builder = assignRoleToUserWithRequestBuilder(userId: userId, assignRoleRequest: assignRoleRequest, disableNotifications: disableNotifications) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func assignRoleToUserWithRequestBuilder(userId: String, assignRoleRequest: AssignRoleRequest, disableNotifications: String? = nil) -> RequestBuilder<Role>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/roles"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: assignRoleRequest)

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "disableNotifications": disableNotifications?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Role>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Change Password
     
     - parameter userId: (path)  
     - parameter changePasswordRequest: (body)  
     - parameter strict: (query)  (optional)
     - returns: AnyPublisher<UserCredentials, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func changePassword(userId: String, changePasswordRequest: ChangePasswordRequest, strict: Bool? = nil) -> AnyPublisher<UserCredentials, Error> {
        return Future<UserCredentials, Error>.init { promise in
            guard let builder = self.changePasswordWithRequestBuilder(userId: userId, changePasswordRequest: changePasswordRequest, strict: strict) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Change Password
     
     - parameter userId: (path)  
     - parameter changePasswordRequest: (body)  
     - parameter strict: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func changePassword(userId: String, changePasswordRequest: ChangePasswordRequest, strict: Bool? = nil, completion: @escaping ((_ result: Swift.Result<UserCredentials, Error>) -> Void)) {
        guard let builder = changePasswordWithRequestBuilder(userId: userId, changePasswordRequest: changePasswordRequest, strict: strict) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func changePasswordWithRequestBuilder(userId: String, changePasswordRequest: ChangePasswordRequest, strict: Bool? = nil) -> RequestBuilder<UserCredentials>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/credentials/change_password"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: changePasswordRequest)

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "strict": strict?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<UserCredentials>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Change Recovery Question
     
     - parameter userId: (path)  
     - parameter userCredentials: (body)  
     - returns: AnyPublisher<UserCredentials, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func changeRecoveryQuestion(userId: String, userCredentials: UserCredentials) -> AnyPublisher<UserCredentials, Error> {
        return Future<UserCredentials, Error>.init { promise in
            guard let builder = self.changeRecoveryQuestionWithRequestBuilder(userId: userId, userCredentials: userCredentials) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Change Recovery Question
     
     - parameter userId: (path)  
     - parameter userCredentials: (body)  
     - parameter completion: completion handler to receive the result
     */
    func changeRecoveryQuestion(userId: String, userCredentials: UserCredentials, completion: @escaping ((_ result: Swift.Result<UserCredentials, Error>) -> Void)) {
        guard let builder = changeRecoveryQuestionWithRequestBuilder(userId: userId, userCredentials: userCredentials) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func changeRecoveryQuestionWithRequestBuilder(userId: String, userCredentials: UserCredentials) -> RequestBuilder<UserCredentials>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/credentials/change_recovery_question"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: userCredentials)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<UserCredentials>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter oauthTokens: (query) Revoke issued OpenID Connect and OAuth refresh and access tokens (optional, default to false)
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func clearUserSessions(userId: String, oauthTokens: Bool? = nil) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.clearUserSessionsWithRequestBuilder(userId: userId, oauthTokens: oauthTokens) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter oauthTokens: (query) Revoke issued OpenID Connect and OAuth refresh and access tokens (optional, default to false)
     - parameter completion: completion handler to receive the result
     */
    func clearUserSessions(userId: String, oauthTokens: Bool? = nil, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = clearUserSessionsWithRequestBuilder(userId: userId, oauthTokens: oauthTokens) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func clearUserSessionsWithRequestBuilder(userId: String, oauthTokens: Bool? = nil) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/sessions"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "oauthTokens": oauthTokens?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Create User
     
     - parameter body: (body)  
     - parameter activate: (query) Executes activation lifecycle operation when creating the user (optional, default to true)
     - parameter provider: (query) Indicates whether to create a user with a specified authentication provider (optional, default to false)
     - parameter nextLogin: (query) With activate&#x3D;true, set nextLogin to \&quot;changePassword\&quot; to have the password be EXPIRED, so user must change it the next time they log in. (optional)
     - returns: AnyPublisher<User, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func createUser(body: CreateUserRequest, activate: Bool? = nil, provider: Bool? = nil, nextLogin: String? = nil) -> AnyPublisher<User, Error> {
        return Future<User, Error>.init { promise in
            guard let builder = self.createUserWithRequestBuilder(body: body, activate: activate, provider: provider, nextLogin: nextLogin) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Create User
     
     - parameter body: (body)  
     - parameter activate: (query) Executes activation lifecycle operation when creating the user (optional, default to true)
     - parameter provider: (query) Indicates whether to create a user with a specified authentication provider (optional, default to false)
     - parameter nextLogin: (query) With activate&#x3D;true, set nextLogin to \&quot;changePassword\&quot; to have the password be EXPIRED, so user must change it the next time they log in. (optional)
     - parameter completion: completion handler to receive the result
     */
    func createUser(body: CreateUserRequest, activate: Bool? = nil, provider: Bool? = nil, nextLogin: String? = nil, completion: @escaping ((_ result: Swift.Result<User, Error>) -> Void)) {
        guard let builder = createUserWithRequestBuilder(body: body, activate: activate, provider: provider, nextLogin: nextLogin) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func createUserWithRequestBuilder(body: CreateUserRequest, activate: Bool? = nil, provider: Bool? = nil, nextLogin: String? = nil) -> RequestBuilder<User>? {
        guard let api = api else {
            return nil
        }
        let path = "/api/v1/users"
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: body)

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "activate": activate?.encodeToJSON(),
            "provider": provider?.encodeToJSON(),
            "nextLogin": nextLogin?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<User>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Delete User
     
     - parameter userId: (path)  
     - parameter sendEmail: (query)  (optional, default to false)
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func deactivateOrDeleteUser(userId: String, sendEmail: Bool? = nil) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.deactivateOrDeleteUserWithRequestBuilder(userId: userId, sendEmail: sendEmail) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Delete User
     
     - parameter userId: (path)  
     - parameter sendEmail: (query)  (optional, default to false)
     - parameter completion: completion handler to receive the result
     */
    func deactivateOrDeleteUser(userId: String, sendEmail: Bool? = nil, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = deactivateOrDeleteUserWithRequestBuilder(userId: userId, sendEmail: sendEmail) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func deactivateOrDeleteUserWithRequestBuilder(userId: String, sendEmail: Bool? = nil) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "sendEmail": sendEmail?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Deactivate User
     
     - parameter userId: (path)  
     - parameter sendEmail: (query)  (optional, default to false)
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func deactivateUser(userId: String, sendEmail: Bool? = nil) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.deactivateUserWithRequestBuilder(userId: userId, sendEmail: sendEmail) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Deactivate User
     
     - parameter userId: (path)  
     - parameter sendEmail: (query)  (optional, default to false)
     - parameter completion: completion handler to receive the result
     */
    func deactivateUser(userId: String, sendEmail: Bool? = nil, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = deactivateUserWithRequestBuilder(userId: userId, sendEmail: sendEmail) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func deactivateUserWithRequestBuilder(userId: String, sendEmail: Bool? = nil) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/lifecycle/deactivate"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "sendEmail": sendEmail?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Expire Password
     
     - parameter userId: (path)  
     - parameter tempPassword: (query) When set to &#39;true&#39; the user&#39;s password is reset to a temporary password that is returned. When omitted or set to &#39;false&#39; the user will be required to change their password at their next login. (optional, default to false)
     - returns: AnyPublisher<User, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func expirePassword(userId: String, tempPassword: Bool? = nil) -> AnyPublisher<User, Error> {
        return Future<User, Error>.init { promise in
            guard let builder = self.expirePasswordWithRequestBuilder(userId: userId, tempPassword: tempPassword) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Expire Password
     
     - parameter userId: (path)  
     - parameter tempPassword: (query) When set to &#39;true&#39; the user&#39;s password is reset to a temporary password that is returned. When omitted or set to &#39;false&#39; the user will be required to change their password at their next login. (optional, default to false)
     - parameter completion: completion handler to receive the result
     */
    func expirePassword(userId: String, tempPassword: Bool? = nil, completion: @escaping ((_ result: Swift.Result<User, Error>) -> Void)) {
        guard let builder = expirePasswordWithRequestBuilder(userId: userId, tempPassword: tempPassword) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func expirePasswordWithRequestBuilder(userId: String, tempPassword: Bool? = nil) -> RequestBuilder<User>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/lifecycle/expire_password"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "tempPassword": tempPassword?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<User>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Forgot Password
     
     - parameter userId: (path)  
     - parameter sendEmail: (query) Determines whether an email is sent to the user. This only applies when &#39;user&#39; is not provided in the request body. (optional, default to true)
     - parameter userCredentials: (body) Factor (optional)
     - returns: AnyPublisher<ForgotPasswordResponse, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func forgotPassword(userId: String, sendEmail: Bool? = nil, userCredentials: UserCredentials? = nil) -> AnyPublisher<ForgotPasswordResponse, Error> {
        return Future<ForgotPasswordResponse, Error>.init { promise in
            guard let builder = self.forgotPasswordWithRequestBuilder(userId: userId, sendEmail: sendEmail, userCredentials: userCredentials) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Forgot Password
     
     - parameter userId: (path)  
     - parameter sendEmail: (query) Determines whether an email is sent to the user. This only applies when &#39;user&#39; is not provided in the request body. (optional, default to true)
     - parameter userCredentials: (body) Factor (optional)
     - parameter completion: completion handler to receive the result
     */
    func forgotPassword(userId: String, sendEmail: Bool? = nil, userCredentials: UserCredentials? = nil, completion: @escaping ((_ result: Swift.Result<ForgotPasswordResponse, Error>) -> Void)) {
        guard let builder = forgotPasswordWithRequestBuilder(userId: userId, sendEmail: sendEmail, userCredentials: userCredentials) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func forgotPasswordWithRequestBuilder(userId: String, sendEmail: Bool? = nil, userCredentials: UserCredentials? = nil) -> RequestBuilder<ForgotPasswordResponse>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/credentials/forgot_password"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: userCredentials)

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "sendEmail": sendEmail?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<ForgotPasswordResponse>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter relationshipName: (path)  
     - parameter after: (query)  (optional)
     - parameter limit: (query)  (optional, default to -1)
     - returns: AnyPublisher<[AnyCodable], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getLinkedObjectsForUser(userId: String, relationshipName: String, after: String? = nil, limit: Int? = nil) -> AnyPublisher<[AnyCodable], Error> {
        return Future<[AnyCodable], Error>.init { promise in
            guard let builder = self.getLinkedObjectsForUserWithRequestBuilder(userId: userId, relationshipName: relationshipName, after: after, limit: limit) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter relationshipName: (path)  
     - parameter after: (query)  (optional)
     - parameter limit: (query)  (optional, default to -1)
     - parameter completion: completion handler to receive the result
     */
    func getLinkedObjectsForUser(userId: String, relationshipName: String, after: String? = nil, limit: Int? = nil, completion: @escaping ((_ result: Swift.Result<[AnyCodable], Error>) -> Void)) {
        guard let builder = getLinkedObjectsForUserWithRequestBuilder(userId: userId, relationshipName: relationshipName, after: after, limit: limit) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func getLinkedObjectsForUserWithRequestBuilder(userId: String, relationshipName: String, after: String? = nil, limit: Int? = nil) -> RequestBuilder<[AnyCodable]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/linkedObjects/{relationshipName}"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let relationshipNamePreEscape = "\(APIHelper.mapValueToPathItem(relationshipName))"
        let relationshipNamePostEscape = relationshipNamePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{relationshipName}", with: relationshipNamePostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "after": after?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[AnyCodable]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter clientId: (path)  
     - parameter tokenId: (path)  
     - parameter expand: (query)  (optional)
     - parameter limit: (query)  (optional, default to 20)
     - parameter after: (query)  (optional)
     - returns: AnyPublisher<OAuth2RefreshToken, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getRefreshTokenForUserAndClient(userId: String, clientId: String, tokenId: String, expand: String? = nil, limit: Int? = nil, after: String? = nil) -> AnyPublisher<OAuth2RefreshToken, Error> {
        return Future<OAuth2RefreshToken, Error>.init { promise in
            guard let builder = self.getRefreshTokenForUserAndClientWithRequestBuilder(userId: userId, clientId: clientId, tokenId: tokenId, expand: expand, limit: limit, after: after) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter clientId: (path)  
     - parameter tokenId: (path)  
     - parameter expand: (query)  (optional)
     - parameter limit: (query)  (optional, default to 20)
     - parameter after: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func getRefreshTokenForUserAndClient(userId: String, clientId: String, tokenId: String, expand: String? = nil, limit: Int? = nil, after: String? = nil, completion: @escaping ((_ result: Swift.Result<OAuth2RefreshToken, Error>) -> Void)) {
        guard let builder = getRefreshTokenForUserAndClientWithRequestBuilder(userId: userId, clientId: clientId, tokenId: tokenId, expand: expand, limit: limit, after: after) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func getRefreshTokenForUserAndClientWithRequestBuilder(userId: String, clientId: String, tokenId: String, expand: String? = nil, limit: Int? = nil, after: String? = nil) -> RequestBuilder<OAuth2RefreshToken>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/clients/{clientId}/tokens/{tokenId}"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let clientIdPreEscape = "\(APIHelper.mapValueToPathItem(clientId))"
        let clientIdPostEscape = clientIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{clientId}", with: clientIdPostEscape, options: .literal, range: nil)
        let tokenIdPreEscape = "\(APIHelper.mapValueToPathItem(tokenId))"
        let tokenIdPostEscape = tokenIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{tokenId}", with: tokenIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "expand": expand?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "after": after?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<OAuth2RefreshToken>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get User
     
     - parameter userId: (path)  
     - returns: AnyPublisher<User, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getUser(userId: String) -> AnyPublisher<User, Error> {
        return Future<User, Error>.init { promise in
            guard let builder = self.getUserWithRequestBuilder(userId: userId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Get User
     
     - parameter userId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func getUser(userId: String, completion: @escaping ((_ result: Swift.Result<User, Error>) -> Void)) {
        guard let builder = getUserWithRequestBuilder(userId: userId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func getUserWithRequestBuilder(userId: String) -> RequestBuilder<User>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<User>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter grantId: (path)  
     - parameter expand: (query)  (optional)
     - returns: AnyPublisher<OAuth2ScopeConsentGrant, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getUserGrant(userId: String, grantId: String, expand: String? = nil) -> AnyPublisher<OAuth2ScopeConsentGrant, Error> {
        return Future<OAuth2ScopeConsentGrant, Error>.init { promise in
            guard let builder = self.getUserGrantWithRequestBuilder(userId: userId, grantId: grantId, expand: expand) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter grantId: (path)  
     - parameter expand: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func getUserGrant(userId: String, grantId: String, expand: String? = nil, completion: @escaping ((_ result: Swift.Result<OAuth2ScopeConsentGrant, Error>) -> Void)) {
        guard let builder = getUserGrantWithRequestBuilder(userId: userId, grantId: grantId, expand: expand) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func getUserGrantWithRequestBuilder(userId: String, grantId: String, expand: String? = nil) -> RequestBuilder<OAuth2ScopeConsentGrant>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/grants/{grantId}"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let grantIdPreEscape = "\(APIHelper.mapValueToPathItem(grantId))"
        let grantIdPostEscape = grantIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{grantId}", with: grantIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "expand": expand?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<OAuth2ScopeConsentGrant>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get Assigned App Links
     
     - parameter userId: (path)  
     - returns: AnyPublisher<[AppLink], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listAppLinks(userId: String) -> AnyPublisher<[AppLink], Error> {
        return Future<[AppLink], Error>.init { promise in
            guard let builder = self.listAppLinksWithRequestBuilder(userId: userId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Get Assigned App Links
     
     - parameter userId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func listAppLinks(userId: String, completion: @escaping ((_ result: Swift.Result<[AppLink], Error>) -> Void)) {
        guard let builder = listAppLinksWithRequestBuilder(userId: userId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listAppLinksWithRequestBuilder(userId: String) -> RequestBuilder<[AppLink]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/appLinks"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[AppLink]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter roleId: (path)  
     - parameter after: (query)  (optional)
     - parameter limit: (query)  (optional, default to 20)
     - returns: AnyPublisher<[CatalogApplication], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listApplicationTargetsForApplicationAdministratorRoleForUser(userId: String, roleId: String, after: String? = nil, limit: Int? = nil) -> AnyPublisher<[CatalogApplication], Error> {
        return Future<[CatalogApplication], Error>.init { promise in
            guard let builder = self.listApplicationTargetsForApplicationAdministratorRoleForUserWithRequestBuilder(userId: userId, roleId: roleId, after: after, limit: limit) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter roleId: (path)  
     - parameter after: (query)  (optional)
     - parameter limit: (query)  (optional, default to 20)
     - parameter completion: completion handler to receive the result
     */
    func listApplicationTargetsForApplicationAdministratorRoleForUser(userId: String, roleId: String, after: String? = nil, limit: Int? = nil, completion: @escaping ((_ result: Swift.Result<[CatalogApplication], Error>) -> Void)) {
        guard let builder = listApplicationTargetsForApplicationAdministratorRoleForUserWithRequestBuilder(userId: userId, roleId: roleId, after: after, limit: limit) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listApplicationTargetsForApplicationAdministratorRoleForUserWithRequestBuilder(userId: String, roleId: String, after: String? = nil, limit: Int? = nil) -> RequestBuilder<[CatalogApplication]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/roles/{roleId}/targets/catalog/apps"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let roleIdPreEscape = "\(APIHelper.mapValueToPathItem(roleId))"
        let roleIdPostEscape = roleIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{roleId}", with: roleIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "after": after?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[CatalogApplication]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter expand: (query)  (optional)
     - returns: AnyPublisher<[Role], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listAssignedRolesForUser(userId: String, expand: String? = nil) -> AnyPublisher<[Role], Error> {
        return Future<[Role], Error>.init { promise in
            guard let builder = self.listAssignedRolesForUserWithRequestBuilder(userId: userId, expand: expand) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter expand: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func listAssignedRolesForUser(userId: String, expand: String? = nil, completion: @escaping ((_ result: Swift.Result<[Role], Error>) -> Void)) {
        guard let builder = listAssignedRolesForUserWithRequestBuilder(userId: userId, expand: expand) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listAssignedRolesForUserWithRequestBuilder(userId: String, expand: String? = nil) -> RequestBuilder<[Role]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/roles"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "expand": expand?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[Role]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter clientId: (path)  
     - parameter expand: (query)  (optional)
     - parameter after: (query)  (optional)
     - parameter limit: (query)  (optional, default to 20)
     - returns: AnyPublisher<[OAuth2ScopeConsentGrant], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listGrantsForUserAndClient(userId: String, clientId: String, expand: String? = nil, after: String? = nil, limit: Int? = nil) -> AnyPublisher<[OAuth2ScopeConsentGrant], Error> {
        return Future<[OAuth2ScopeConsentGrant], Error>.init { promise in
            guard let builder = self.listGrantsForUserAndClientWithRequestBuilder(userId: userId, clientId: clientId, expand: expand, after: after, limit: limit) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter clientId: (path)  
     - parameter expand: (query)  (optional)
     - parameter after: (query)  (optional)
     - parameter limit: (query)  (optional, default to 20)
     - parameter completion: completion handler to receive the result
     */
    func listGrantsForUserAndClient(userId: String, clientId: String, expand: String? = nil, after: String? = nil, limit: Int? = nil, completion: @escaping ((_ result: Swift.Result<[OAuth2ScopeConsentGrant], Error>) -> Void)) {
        guard let builder = listGrantsForUserAndClientWithRequestBuilder(userId: userId, clientId: clientId, expand: expand, after: after, limit: limit) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listGrantsForUserAndClientWithRequestBuilder(userId: String, clientId: String, expand: String? = nil, after: String? = nil, limit: Int? = nil) -> RequestBuilder<[OAuth2ScopeConsentGrant]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/clients/{clientId}/grants"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let clientIdPreEscape = "\(APIHelper.mapValueToPathItem(clientId))"
        let clientIdPostEscape = clientIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{clientId}", with: clientIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "expand": expand?.encodeToJSON(),
            "after": after?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[OAuth2ScopeConsentGrant]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter roleId: (path)  
     - parameter after: (query)  (optional)
     - parameter limit: (query)  (optional, default to 20)
     - returns: AnyPublisher<[Group], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listGroupTargetsForRole(userId: String, roleId: String, after: String? = nil, limit: Int? = nil) -> AnyPublisher<[Group], Error> {
        return Future<[Group], Error>.init { promise in
            guard let builder = self.listGroupTargetsForRoleWithRequestBuilder(userId: userId, roleId: roleId, after: after, limit: limit) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter roleId: (path)  
     - parameter after: (query)  (optional)
     - parameter limit: (query)  (optional, default to 20)
     - parameter completion: completion handler to receive the result
     */
    func listGroupTargetsForRole(userId: String, roleId: String, after: String? = nil, limit: Int? = nil, completion: @escaping ((_ result: Swift.Result<[Group], Error>) -> Void)) {
        guard let builder = listGroupTargetsForRoleWithRequestBuilder(userId: userId, roleId: roleId, after: after, limit: limit) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listGroupTargetsForRoleWithRequestBuilder(userId: String, roleId: String, after: String? = nil, limit: Int? = nil) -> RequestBuilder<[Group]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/roles/{roleId}/targets/groups"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let roleIdPreEscape = "\(APIHelper.mapValueToPathItem(roleId))"
        let roleIdPostEscape = roleIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{roleId}", with: roleIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "after": after?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[Group]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter clientId: (path)  
     - parameter expand: (query)  (optional)
     - parameter after: (query)  (optional)
     - parameter limit: (query)  (optional, default to 20)
     - returns: AnyPublisher<[OAuth2RefreshToken], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listRefreshTokensForUserAndClient(userId: String, clientId: String, expand: String? = nil, after: String? = nil, limit: Int? = nil) -> AnyPublisher<[OAuth2RefreshToken], Error> {
        return Future<[OAuth2RefreshToken], Error>.init { promise in
            guard let builder = self.listRefreshTokensForUserAndClientWithRequestBuilder(userId: userId, clientId: clientId, expand: expand, after: after, limit: limit) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter clientId: (path)  
     - parameter expand: (query)  (optional)
     - parameter after: (query)  (optional)
     - parameter limit: (query)  (optional, default to 20)
     - parameter completion: completion handler to receive the result
     */
    func listRefreshTokensForUserAndClient(userId: String, clientId: String, expand: String? = nil, after: String? = nil, limit: Int? = nil, completion: @escaping ((_ result: Swift.Result<[OAuth2RefreshToken], Error>) -> Void)) {
        guard let builder = listRefreshTokensForUserAndClientWithRequestBuilder(userId: userId, clientId: clientId, expand: expand, after: after, limit: limit) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listRefreshTokensForUserAndClientWithRequestBuilder(userId: String, clientId: String, expand: String? = nil, after: String? = nil, limit: Int? = nil) -> RequestBuilder<[OAuth2RefreshToken]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/clients/{clientId}/tokens"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let clientIdPreEscape = "\(APIHelper.mapValueToPathItem(clientId))"
        let clientIdPostEscape = clientIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{clientId}", with: clientIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "expand": expand?.encodeToJSON(),
            "after": after?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[OAuth2RefreshToken]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - returns: AnyPublisher<[OAuth2Client], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listUserClients(userId: String) -> AnyPublisher<[OAuth2Client], Error> {
        return Future<[OAuth2Client], Error>.init { promise in
            guard let builder = self.listUserClientsWithRequestBuilder(userId: userId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func listUserClients(userId: String, completion: @escaping ((_ result: Swift.Result<[OAuth2Client], Error>) -> Void)) {
        guard let builder = listUserClientsWithRequestBuilder(userId: userId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listUserClientsWithRequestBuilder(userId: String) -> RequestBuilder<[OAuth2Client]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/clients"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[OAuth2Client]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter scopeId: (query)  (optional)
     - parameter expand: (query)  (optional)
     - parameter after: (query)  (optional)
     - parameter limit: (query)  (optional, default to 20)
     - returns: AnyPublisher<[OAuth2ScopeConsentGrant], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listUserGrants(userId: String, scopeId: String? = nil, expand: String? = nil, after: String? = nil, limit: Int? = nil) -> AnyPublisher<[OAuth2ScopeConsentGrant], Error> {
        return Future<[OAuth2ScopeConsentGrant], Error>.init { promise in
            guard let builder = self.listUserGrantsWithRequestBuilder(userId: userId, scopeId: scopeId, expand: expand, after: after, limit: limit) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter scopeId: (query)  (optional)
     - parameter expand: (query)  (optional)
     - parameter after: (query)  (optional)
     - parameter limit: (query)  (optional, default to 20)
     - parameter completion: completion handler to receive the result
     */
    func listUserGrants(userId: String, scopeId: String? = nil, expand: String? = nil, after: String? = nil, limit: Int? = nil, completion: @escaping ((_ result: Swift.Result<[OAuth2ScopeConsentGrant], Error>) -> Void)) {
        guard let builder = listUserGrantsWithRequestBuilder(userId: userId, scopeId: scopeId, expand: expand, after: after, limit: limit) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listUserGrantsWithRequestBuilder(userId: String, scopeId: String? = nil, expand: String? = nil, after: String? = nil, limit: Int? = nil) -> RequestBuilder<[OAuth2ScopeConsentGrant]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/grants"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "scopeId": scopeId?.encodeToJSON(),
            "expand": expand?.encodeToJSON(),
            "after": after?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[OAuth2ScopeConsentGrant]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get Member Groups
     
     - parameter userId: (path)  
     - returns: AnyPublisher<[Group], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listUserGroups(userId: String) -> AnyPublisher<[Group], Error> {
        return Future<[Group], Error>.init { promise in
            guard let builder = self.listUserGroupsWithRequestBuilder(userId: userId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Get Member Groups
     
     - parameter userId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func listUserGroups(userId: String, completion: @escaping ((_ result: Swift.Result<[Group], Error>) -> Void)) {
        guard let builder = listUserGroupsWithRequestBuilder(userId: userId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listUserGroupsWithRequestBuilder(userId: String) -> RequestBuilder<[Group]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/groups"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[Group]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Listing IdPs associated with a user
     
     - parameter userId: (path)  
     - returns: AnyPublisher<[IdentityProvider], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listUserIdentityProviders(userId: String) -> AnyPublisher<[IdentityProvider], Error> {
        return Future<[IdentityProvider], Error>.init { promise in
            guard let builder = self.listUserIdentityProvidersWithRequestBuilder(userId: userId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Listing IdPs associated with a user
     
     - parameter userId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func listUserIdentityProviders(userId: String, completion: @escaping ((_ result: Swift.Result<[IdentityProvider], Error>) -> Void)) {
        guard let builder = listUserIdentityProvidersWithRequestBuilder(userId: userId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listUserIdentityProvidersWithRequestBuilder(userId: String) -> RequestBuilder<[IdentityProvider]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/idps"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[IdentityProvider]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     List Users
     
     - parameter q: (query) Finds a user that matches firstName, lastName, and email properties (optional)
     - parameter after: (query) Specifies the pagination cursor for the next page of users (optional)
     - parameter limit: (query) Specifies the number of results returned (optional, default to 10)
     - parameter filter: (query) Filters users with a supported expression for a subset of properties (optional)
     - parameter search: (query) Searches for users with a supported filtering  expression for most properties (optional)
     - parameter sortBy: (query)  (optional)
     - parameter sortOrder: (query)  (optional)
     - returns: AnyPublisher<[User], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listUsers(q: String? = nil, after: String? = nil, limit: Int? = nil, filter: String? = nil, search: String? = nil, sortBy: String? = nil, sortOrder: String? = nil) -> AnyPublisher<[User], Error> {
        return Future<[User], Error>.init { promise in
            guard let builder = self.listUsersWithRequestBuilder(q: q, after: after, limit: limit, filter: filter, search: search, sortBy: sortBy, sortOrder: sortOrder) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     List Users
     
     - parameter q: (query) Finds a user that matches firstName, lastName, and email properties (optional)
     - parameter after: (query) Specifies the pagination cursor for the next page of users (optional)
     - parameter limit: (query) Specifies the number of results returned (optional, default to 10)
     - parameter filter: (query) Filters users with a supported expression for a subset of properties (optional)
     - parameter search: (query) Searches for users with a supported filtering  expression for most properties (optional)
     - parameter sortBy: (query)  (optional)
     - parameter sortOrder: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func listUsers(q: String? = nil, after: String? = nil, limit: Int? = nil, filter: String? = nil, search: String? = nil, sortBy: String? = nil, sortOrder: String? = nil, completion: @escaping ((_ result: Swift.Result<[User], Error>) -> Void)) {
        guard let builder = listUsersWithRequestBuilder(q: q, after: after, limit: limit, filter: filter, search: search, sortBy: sortBy, sortOrder: sortOrder) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listUsersWithRequestBuilder(q: String? = nil, after: String? = nil, limit: Int? = nil, filter: String? = nil, search: String? = nil, sortBy: String? = nil, sortOrder: String? = nil) -> RequestBuilder<[User]>? {
        guard let api = api else {
            return nil
        }
        let path = "/api/v1/users"
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "q": q?.encodeToJSON(),
            "after": after?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "filter": filter?.encodeToJSON(),
            "search": search?.encodeToJSON(),
            "sortBy": sortBy?.encodeToJSON(),
            "sortOrder": sortOrder?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[User]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter user: (body)  
     - parameter strict: (query)  (optional)
     - returns: AnyPublisher<User, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func partialUpdateUser(userId: String, user: User, strict: Bool? = nil) -> AnyPublisher<User, Error> {
        return Future<User, Error>.init { promise in
            guard let builder = self.partialUpdateUserWithRequestBuilder(userId: userId, user: user, strict: strict) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter user: (body)  
     - parameter strict: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func partialUpdateUser(userId: String, user: User, strict: Bool? = nil, completion: @escaping ((_ result: Swift.Result<User, Error>) -> Void)) {
        guard let builder = partialUpdateUserWithRequestBuilder(userId: userId, user: user, strict: strict) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func partialUpdateUserWithRequestBuilder(userId: String, user: User, strict: Bool? = nil) -> RequestBuilder<User>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: user)

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "strict": strict?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<User>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Reactivate User
     
     - parameter userId: (path)  
     - parameter sendEmail: (query) Sends an activation email to the user if true (optional, default to false)
     - returns: AnyPublisher<UserActivationToken, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func reactivateUser(userId: String, sendEmail: Bool? = nil) -> AnyPublisher<UserActivationToken, Error> {
        return Future<UserActivationToken, Error>.init { promise in
            guard let builder = self.reactivateUserWithRequestBuilder(userId: userId, sendEmail: sendEmail) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Reactivate User
     
     - parameter userId: (path)  
     - parameter sendEmail: (query) Sends an activation email to the user if true (optional, default to false)
     - parameter completion: completion handler to receive the result
     */
    func reactivateUser(userId: String, sendEmail: Bool? = nil, completion: @escaping ((_ result: Swift.Result<UserActivationToken, Error>) -> Void)) {
        guard let builder = reactivateUserWithRequestBuilder(userId: userId, sendEmail: sendEmail) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func reactivateUserWithRequestBuilder(userId: String, sendEmail: Bool? = nil) -> RequestBuilder<UserActivationToken>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/lifecycle/reactivate"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "sendEmail": sendEmail?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<UserActivationToken>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Remove App Instance Target to App Administrator Role given to a User
     
     - parameter userId: (path)  
     - parameter roleId: (path)  
     - parameter appName: (path)  
     - parameter applicationId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func removeApplicationTargetFromAdministratorRoleForUser(userId: String, roleId: String, appName: String, applicationId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.removeApplicationTargetFromAdministratorRoleForUserWithRequestBuilder(userId: userId, roleId: roleId, appName: appName, applicationId: applicationId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Remove App Instance Target to App Administrator Role given to a User
     
     - parameter userId: (path)  
     - parameter roleId: (path)  
     - parameter appName: (path)  
     - parameter applicationId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func removeApplicationTargetFromAdministratorRoleForUser(userId: String, roleId: String, appName: String, applicationId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = removeApplicationTargetFromAdministratorRoleForUserWithRequestBuilder(userId: userId, roleId: roleId, appName: appName, applicationId: applicationId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func removeApplicationTargetFromAdministratorRoleForUserWithRequestBuilder(userId: String, roleId: String, appName: String, applicationId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/roles/{roleId}/targets/catalog/apps/{appName}/{applicationId}"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let roleIdPreEscape = "\(APIHelper.mapValueToPathItem(roleId))"
        let roleIdPostEscape = roleIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{roleId}", with: roleIdPostEscape, options: .literal, range: nil)
        let appNamePreEscape = "\(APIHelper.mapValueToPathItem(appName))"
        let appNamePostEscape = appNamePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appName}", with: appNamePostEscape, options: .literal, range: nil)
        let applicationIdPreEscape = "\(APIHelper.mapValueToPathItem(applicationId))"
        let applicationIdPostEscape = applicationIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{applicationId}", with: applicationIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter roleId: (path)  
     - parameter appName: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func removeApplicationTargetFromApplicationAdministratorRoleForUser(userId: String, roleId: String, appName: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.removeApplicationTargetFromApplicationAdministratorRoleForUserWithRequestBuilder(userId: userId, roleId: roleId, appName: appName) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter roleId: (path)  
     - parameter appName: (path)  
     - parameter completion: completion handler to receive the result
     */
    func removeApplicationTargetFromApplicationAdministratorRoleForUser(userId: String, roleId: String, appName: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = removeApplicationTargetFromApplicationAdministratorRoleForUserWithRequestBuilder(userId: userId, roleId: roleId, appName: appName) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func removeApplicationTargetFromApplicationAdministratorRoleForUserWithRequestBuilder(userId: String, roleId: String, appName: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/roles/{roleId}/targets/catalog/apps/{appName}"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let roleIdPreEscape = "\(APIHelper.mapValueToPathItem(roleId))"
        let roleIdPostEscape = roleIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{roleId}", with: roleIdPostEscape, options: .literal, range: nil)
        let appNamePreEscape = "\(APIHelper.mapValueToPathItem(appName))"
        let appNamePostEscape = appNamePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{appName}", with: appNamePostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter roleId: (path)  
     - parameter groupId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func removeGroupTargetFromRole(userId: String, roleId: String, groupId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.removeGroupTargetFromRoleWithRequestBuilder(userId: userId, roleId: roleId, groupId: groupId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter roleId: (path)  
     - parameter groupId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func removeGroupTargetFromRole(userId: String, roleId: String, groupId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = removeGroupTargetFromRoleWithRequestBuilder(userId: userId, roleId: roleId, groupId: groupId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func removeGroupTargetFromRoleWithRequestBuilder(userId: String, roleId: String, groupId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/roles/{roleId}/targets/groups/{groupId}"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let roleIdPreEscape = "\(APIHelper.mapValueToPathItem(roleId))"
        let roleIdPostEscape = roleIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{roleId}", with: roleIdPostEscape, options: .literal, range: nil)
        let groupIdPreEscape = "\(APIHelper.mapValueToPathItem(groupId))"
        let groupIdPostEscape = groupIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{groupId}", with: groupIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter relationshipName: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func removeLinkedObjectForUser(userId: String, relationshipName: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.removeLinkedObjectForUserWithRequestBuilder(userId: userId, relationshipName: relationshipName) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter relationshipName: (path)  
     - parameter completion: completion handler to receive the result
     */
    func removeLinkedObjectForUser(userId: String, relationshipName: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = removeLinkedObjectForUserWithRequestBuilder(userId: userId, relationshipName: relationshipName) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func removeLinkedObjectForUserWithRequestBuilder(userId: String, relationshipName: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/linkedObjects/{relationshipName}"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let relationshipNamePreEscape = "\(APIHelper.mapValueToPathItem(relationshipName))"
        let relationshipNamePostEscape = relationshipNamePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{relationshipName}", with: relationshipNamePostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter roleId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func removeRoleFromUser(userId: String, roleId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.removeRoleFromUserWithRequestBuilder(userId: userId, roleId: roleId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter roleId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func removeRoleFromUser(userId: String, roleId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = removeRoleFromUserWithRequestBuilder(userId: userId, roleId: roleId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func removeRoleFromUserWithRequestBuilder(userId: String, roleId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/roles/{roleId}"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let roleIdPreEscape = "\(APIHelper.mapValueToPathItem(roleId))"
        let roleIdPostEscape = roleIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{roleId}", with: roleIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Reset Factors
     
     - parameter userId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func resetFactors(userId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.resetFactorsWithRequestBuilder(userId: userId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Reset Factors
     
     - parameter userId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func resetFactors(userId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = resetFactorsWithRequestBuilder(userId: userId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func resetFactorsWithRequestBuilder(userId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/lifecycle/reset_factors"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Reset Password
     
     - parameter userId: (path)  
     - parameter sendEmail: (query)  
     - returns: AnyPublisher<ResetPasswordToken, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func resetPassword(userId: String, sendEmail: Bool) -> AnyPublisher<ResetPasswordToken, Error> {
        return Future<ResetPasswordToken, Error>.init { promise in
            guard let builder = self.resetPasswordWithRequestBuilder(userId: userId, sendEmail: sendEmail) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Reset Password
     
     - parameter userId: (path)  
     - parameter sendEmail: (query)  
     - parameter completion: completion handler to receive the result
     */
    func resetPassword(userId: String, sendEmail: Bool, completion: @escaping ((_ result: Swift.Result<ResetPasswordToken, Error>) -> Void)) {
        guard let builder = resetPasswordWithRequestBuilder(userId: userId, sendEmail: sendEmail) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func resetPasswordWithRequestBuilder(userId: String, sendEmail: Bool) -> RequestBuilder<ResetPasswordToken>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/lifecycle/reset_password"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "sendEmail": sendEmail.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<ResetPasswordToken>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter clientId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func revokeGrantsForUserAndClient(userId: String, clientId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.revokeGrantsForUserAndClientWithRequestBuilder(userId: userId, clientId: clientId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter clientId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func revokeGrantsForUserAndClient(userId: String, clientId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = revokeGrantsForUserAndClientWithRequestBuilder(userId: userId, clientId: clientId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func revokeGrantsForUserAndClientWithRequestBuilder(userId: String, clientId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/clients/{clientId}/grants"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let clientIdPreEscape = "\(APIHelper.mapValueToPathItem(clientId))"
        let clientIdPostEscape = clientIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{clientId}", with: clientIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter clientId: (path)  
     - parameter tokenId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func revokeTokenForUserAndClient(userId: String, clientId: String, tokenId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.revokeTokenForUserAndClientWithRequestBuilder(userId: userId, clientId: clientId, tokenId: tokenId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter clientId: (path)  
     - parameter tokenId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func revokeTokenForUserAndClient(userId: String, clientId: String, tokenId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = revokeTokenForUserAndClientWithRequestBuilder(userId: userId, clientId: clientId, tokenId: tokenId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func revokeTokenForUserAndClientWithRequestBuilder(userId: String, clientId: String, tokenId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/clients/{clientId}/tokens/{tokenId}"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let clientIdPreEscape = "\(APIHelper.mapValueToPathItem(clientId))"
        let clientIdPostEscape = clientIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{clientId}", with: clientIdPostEscape, options: .literal, range: nil)
        let tokenIdPreEscape = "\(APIHelper.mapValueToPathItem(tokenId))"
        let tokenIdPostEscape = tokenIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{tokenId}", with: tokenIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter clientId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func revokeTokensForUserAndClient(userId: String, clientId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.revokeTokensForUserAndClientWithRequestBuilder(userId: userId, clientId: clientId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter clientId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func revokeTokensForUserAndClient(userId: String, clientId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = revokeTokensForUserAndClientWithRequestBuilder(userId: userId, clientId: clientId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func revokeTokensForUserAndClientWithRequestBuilder(userId: String, clientId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/clients/{clientId}/tokens"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let clientIdPreEscape = "\(APIHelper.mapValueToPathItem(clientId))"
        let clientIdPostEscape = clientIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{clientId}", with: clientIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - parameter grantId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func revokeUserGrant(userId: String, grantId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.revokeUserGrantWithRequestBuilder(userId: userId, grantId: grantId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter grantId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func revokeUserGrant(userId: String, grantId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = revokeUserGrantWithRequestBuilder(userId: userId, grantId: grantId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func revokeUserGrantWithRequestBuilder(userId: String, grantId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/grants/{grantId}"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let grantIdPreEscape = "\(APIHelper.mapValueToPathItem(grantId))"
        let grantIdPostEscape = grantIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{grantId}", with: grantIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter userId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func revokeUserGrants(userId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.revokeUserGrantsWithRequestBuilder(userId: userId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter userId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func revokeUserGrants(userId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = revokeUserGrantsWithRequestBuilder(userId: userId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func revokeUserGrantsWithRequestBuilder(userId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/grants"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Set Linked Object for User
     
     - parameter associatedUserId: (path)  
     - parameter primaryRelationshipName: (path)  
     - parameter primaryUserId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func setLinkedObjectForUser(associatedUserId: String, primaryRelationshipName: String, primaryUserId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.setLinkedObjectForUserWithRequestBuilder(associatedUserId: associatedUserId, primaryRelationshipName: primaryRelationshipName, primaryUserId: primaryUserId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Set Linked Object for User
     
     - parameter associatedUserId: (path)  
     - parameter primaryRelationshipName: (path)  
     - parameter primaryUserId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func setLinkedObjectForUser(associatedUserId: String, primaryRelationshipName: String, primaryUserId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = setLinkedObjectForUserWithRequestBuilder(associatedUserId: associatedUserId, primaryRelationshipName: primaryRelationshipName, primaryUserId: primaryUserId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func setLinkedObjectForUserWithRequestBuilder(associatedUserId: String, primaryRelationshipName: String, primaryUserId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{associatedUserId}/linkedObjects/{primaryRelationshipName}/{primaryUserId}"
        let associatedUserIdPreEscape = "\(APIHelper.mapValueToPathItem(associatedUserId))"
        let associatedUserIdPostEscape = associatedUserIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{associatedUserId}", with: associatedUserIdPostEscape, options: .literal, range: nil)
        let primaryRelationshipNamePreEscape = "\(APIHelper.mapValueToPathItem(primaryRelationshipName))"
        let primaryRelationshipNamePostEscape = primaryRelationshipNamePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{primaryRelationshipName}", with: primaryRelationshipNamePostEscape, options: .literal, range: nil)
        let primaryUserIdPreEscape = "\(APIHelper.mapValueToPathItem(primaryUserId))"
        let primaryUserIdPostEscape = primaryUserIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{primaryUserId}", with: primaryUserIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "PUT", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Suspend User
     
     - parameter userId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func suspendUser(userId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.suspendUserWithRequestBuilder(userId: userId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Suspend User
     
     - parameter userId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func suspendUser(userId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = suspendUserWithRequestBuilder(userId: userId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func suspendUserWithRequestBuilder(userId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/lifecycle/suspend"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Unlock User
     
     - parameter userId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func unlockUser(userId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.unlockUserWithRequestBuilder(userId: userId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Unlock User
     
     - parameter userId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func unlockUser(userId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = unlockUserWithRequestBuilder(userId: userId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func unlockUserWithRequestBuilder(userId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/lifecycle/unlock"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Unsuspend User
     
     - parameter userId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func unsuspendUser(userId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.unsuspendUserWithRequestBuilder(userId: userId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Unsuspend User
     
     - parameter userId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func unsuspendUser(userId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = unsuspendUserWithRequestBuilder(userId: userId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func unsuspendUserWithRequestBuilder(userId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}/lifecycle/unsuspend"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Update User
     
     - parameter userId: (path)  
     - parameter user: (body)  
     - parameter strict: (query)  (optional)
     - returns: AnyPublisher<User, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func updateUser(userId: String, user: User, strict: Bool? = nil) -> AnyPublisher<User, Error> {
        return Future<User, Error>.init { promise in
            guard let builder = self.updateUserWithRequestBuilder(userId: userId, user: user, strict: strict) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**
     Update User
     
     - parameter userId: (path)  
     - parameter user: (body)  
     - parameter strict: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func updateUser(userId: String, user: User, strict: Bool? = nil, completion: @escaping ((_ result: Swift.Result<User, Error>) -> Void)) {
        guard let builder = updateUserWithRequestBuilder(userId: userId, user: user, strict: strict) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func updateUserWithRequestBuilder(userId: String, user: User, strict: Bool? = nil) -> RequestBuilder<User>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/users/{userId}"
        let userIdPreEscape = "\(APIHelper.mapValueToPathItem(userId))"
        let userIdPostEscape = userIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{userId}", with: userIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: user)

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "strict": strict?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<User>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "PUT", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

}
}
