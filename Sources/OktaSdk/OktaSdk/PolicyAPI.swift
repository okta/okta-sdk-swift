//
// PolicyAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(Combine)
import Combine
#endif
import AnyCodable

extension OktaSdk.API {


public class PolicyAPI {
    internal weak var api: OktaSdkAPI?

    internal init(api: OktaSdkAPI) {
        self.api = api
    }

    /**

     - parameter policyId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func activatePolicy(policyId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.activatePolicyWithRequestBuilder(policyId: policyId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter policyId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func activatePolicy(policyId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = activatePolicyWithRequestBuilder(policyId: policyId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func activatePolicyWithRequestBuilder(policyId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/policies/{policyId}/lifecycle/activate"
        let policyIdPreEscape = "\(APIHelper.mapValueToPathItem(policyId))"
        let policyIdPostEscape = policyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{policyId}", with: policyIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter policyId: (path)  
     - parameter ruleId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func activatePolicyRule(policyId: String, ruleId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.activatePolicyRuleWithRequestBuilder(policyId: policyId, ruleId: ruleId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter policyId: (path)  
     - parameter ruleId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func activatePolicyRule(policyId: String, ruleId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = activatePolicyRuleWithRequestBuilder(policyId: policyId, ruleId: ruleId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func activatePolicyRuleWithRequestBuilder(policyId: String, ruleId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/policies/{policyId}/rules/{ruleId}/lifecycle/activate"
        let policyIdPreEscape = "\(APIHelper.mapValueToPathItem(policyId))"
        let policyIdPostEscape = policyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{policyId}", with: policyIdPostEscape, options: .literal, range: nil)
        let ruleIdPreEscape = "\(APIHelper.mapValueToPathItem(ruleId))"
        let ruleIdPostEscape = ruleIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{ruleId}", with: ruleIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter policy: (body)  
     - parameter activate: (query)  (optional, default to true)
     - returns: AnyPublisher<Policy, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func createPolicy(policy: Policy, activate: Bool? = nil) -> AnyPublisher<Policy, Error> {
        return Future<Policy, Error>.init { promise in
            guard let builder = self.createPolicyWithRequestBuilder(policy: policy, activate: activate) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter policy: (body)  
     - parameter activate: (query)  (optional, default to true)
     - parameter completion: completion handler to receive the result
     */
    func createPolicy(policy: Policy, activate: Bool? = nil, completion: @escaping ((_ result: Swift.Result<Policy, Error>) -> Void)) {
        guard let builder = createPolicyWithRequestBuilder(policy: policy, activate: activate) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func createPolicyWithRequestBuilder(policy: Policy, activate: Bool? = nil) -> RequestBuilder<Policy>? {
        guard let api = api else {
            return nil
        }
        let path = "/api/v1/policies"
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: policy)

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "activate": activate?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Policy>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter policyId: (path)  
     - parameter policyRule: (body)  
     - returns: AnyPublisher<PolicyRule, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func createPolicyRule(policyId: String, policyRule: PolicyRule) -> AnyPublisher<PolicyRule, Error> {
        return Future<PolicyRule, Error>.init { promise in
            guard let builder = self.createPolicyRuleWithRequestBuilder(policyId: policyId, policyRule: policyRule) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter policyId: (path)  
     - parameter policyRule: (body)  
     - parameter completion: completion handler to receive the result
     */
    func createPolicyRule(policyId: String, policyRule: PolicyRule, completion: @escaping ((_ result: Swift.Result<PolicyRule, Error>) -> Void)) {
        guard let builder = createPolicyRuleWithRequestBuilder(policyId: policyId, policyRule: policyRule) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func createPolicyRuleWithRequestBuilder(policyId: String, policyRule: PolicyRule) -> RequestBuilder<PolicyRule>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/policies/{policyId}/rules"
        let policyIdPreEscape = "\(APIHelper.mapValueToPathItem(policyId))"
        let policyIdPostEscape = policyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{policyId}", with: policyIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: policyRule)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<PolicyRule>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter policyId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func deactivatePolicy(policyId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.deactivatePolicyWithRequestBuilder(policyId: policyId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter policyId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func deactivatePolicy(policyId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = deactivatePolicyWithRequestBuilder(policyId: policyId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func deactivatePolicyWithRequestBuilder(policyId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/policies/{policyId}/lifecycle/deactivate"
        let policyIdPreEscape = "\(APIHelper.mapValueToPathItem(policyId))"
        let policyIdPostEscape = policyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{policyId}", with: policyIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter policyId: (path)  
     - parameter ruleId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func deactivatePolicyRule(policyId: String, ruleId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.deactivatePolicyRuleWithRequestBuilder(policyId: policyId, ruleId: ruleId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter policyId: (path)  
     - parameter ruleId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func deactivatePolicyRule(policyId: String, ruleId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = deactivatePolicyRuleWithRequestBuilder(policyId: policyId, ruleId: ruleId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func deactivatePolicyRuleWithRequestBuilder(policyId: String, ruleId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/policies/{policyId}/rules/{ruleId}/lifecycle/deactivate"
        let policyIdPreEscape = "\(APIHelper.mapValueToPathItem(policyId))"
        let policyIdPostEscape = policyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{policyId}", with: policyIdPostEscape, options: .literal, range: nil)
        let ruleIdPreEscape = "\(APIHelper.mapValueToPathItem(ruleId))"
        let ruleIdPostEscape = ruleIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{ruleId}", with: ruleIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter policyId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func deletePolicy(policyId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.deletePolicyWithRequestBuilder(policyId: policyId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter policyId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func deletePolicy(policyId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = deletePolicyWithRequestBuilder(policyId: policyId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func deletePolicyWithRequestBuilder(policyId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/policies/{policyId}"
        let policyIdPreEscape = "\(APIHelper.mapValueToPathItem(policyId))"
        let policyIdPostEscape = policyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{policyId}", with: policyIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter policyId: (path)  
     - parameter ruleId: (path)  
     - returns: AnyPublisher<Void, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func deletePolicyRule(policyId: String, ruleId: String) -> AnyPublisher<Void, Error> {
        return Future<Void, Error>.init { promise in
            guard let builder = self.deletePolicyRuleWithRequestBuilder(policyId: policyId, ruleId: ruleId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case .success:
                    promise(.success(()))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter policyId: (path)  
     - parameter ruleId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func deletePolicyRule(policyId: String, ruleId: String, completion: @escaping ((_ result: Swift.Result<Void, Error>) -> Void)) {
        guard let builder = deletePolicyRuleWithRequestBuilder(policyId: policyId, ruleId: ruleId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case .success:
                completion(.success(()))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func deletePolicyRuleWithRequestBuilder(policyId: String, ruleId: String) -> RequestBuilder<Void>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/policies/{policyId}/rules/{ruleId}"
        let policyIdPreEscape = "\(APIHelper.mapValueToPathItem(policyId))"
        let policyIdPostEscape = policyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{policyId}", with: policyIdPostEscape, options: .literal, range: nil)
        let ruleIdPreEscape = "\(APIHelper.mapValueToPathItem(ruleId))"
        let ruleIdPostEscape = ruleIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{ruleId}", with: ruleIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Void>.Type = api.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(api: api, method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter policyId: (path)  
     - parameter expand: (query)  (optional)
     - returns: AnyPublisher<Policy, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getPolicy(policyId: String, expand: String? = nil) -> AnyPublisher<Policy, Error> {
        return Future<Policy, Error>.init { promise in
            guard let builder = self.getPolicyWithRequestBuilder(policyId: policyId, expand: expand) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter policyId: (path)  
     - parameter expand: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func getPolicy(policyId: String, expand: String? = nil, completion: @escaping ((_ result: Swift.Result<Policy, Error>) -> Void)) {
        guard let builder = getPolicyWithRequestBuilder(policyId: policyId, expand: expand) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func getPolicyWithRequestBuilder(policyId: String, expand: String? = nil) -> RequestBuilder<Policy>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/policies/{policyId}"
        let policyIdPreEscape = "\(APIHelper.mapValueToPathItem(policyId))"
        let policyIdPostEscape = policyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{policyId}", with: policyIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "expand": expand?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Policy>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter policyId: (path)  
     - parameter ruleId: (path)  
     - returns: AnyPublisher<PolicyRule, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func getPolicyRule(policyId: String, ruleId: String) -> AnyPublisher<PolicyRule, Error> {
        return Future<PolicyRule, Error>.init { promise in
            guard let builder = self.getPolicyRuleWithRequestBuilder(policyId: policyId, ruleId: ruleId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter policyId: (path)  
     - parameter ruleId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func getPolicyRule(policyId: String, ruleId: String, completion: @escaping ((_ result: Swift.Result<PolicyRule, Error>) -> Void)) {
        guard let builder = getPolicyRuleWithRequestBuilder(policyId: policyId, ruleId: ruleId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func getPolicyRuleWithRequestBuilder(policyId: String, ruleId: String) -> RequestBuilder<PolicyRule>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/policies/{policyId}/rules/{ruleId}"
        let policyIdPreEscape = "\(APIHelper.mapValueToPathItem(policyId))"
        let policyIdPostEscape = policyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{policyId}", with: policyIdPostEscape, options: .literal, range: nil)
        let ruleIdPreEscape = "\(APIHelper.mapValueToPathItem(ruleId))"
        let ruleIdPostEscape = ruleIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{ruleId}", with: ruleIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<PolicyRule>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter type: (query)  
     - parameter status: (query)  (optional)
     - parameter expand: (query)  (optional)
     - returns: AnyPublisher<[AuthorizationServerPolicy], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listPolicies(type: String, status: String? = nil, expand: String? = nil) -> AnyPublisher<[AuthorizationServerPolicy], Error> {
        return Future<[AuthorizationServerPolicy], Error>.init { promise in
            guard let builder = self.listPoliciesWithRequestBuilder(type: type, status: status, expand: expand) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter type: (query)  
     - parameter status: (query)  (optional)
     - parameter expand: (query)  (optional)
     - parameter completion: completion handler to receive the result
     */
    func listPolicies(type: String, status: String? = nil, expand: String? = nil, completion: @escaping ((_ result: Swift.Result<[AuthorizationServerPolicy], Error>) -> Void)) {
        guard let builder = listPoliciesWithRequestBuilder(type: type, status: status, expand: expand) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listPoliciesWithRequestBuilder(type: String, status: String? = nil, expand: String? = nil) -> RequestBuilder<[AuthorizationServerPolicy]>? {
        guard let api = api else {
            return nil
        }
        let path = "/api/v1/policies"
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "type": type.encodeToJSON(),
            "status": status?.encodeToJSON(),
            "expand": expand?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[AuthorizationServerPolicy]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter policyId: (path)  
     - returns: AnyPublisher<[PolicyRule], Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func listPolicyRules(policyId: String) -> AnyPublisher<[PolicyRule], Error> {
        return Future<[PolicyRule], Error>.init { promise in
            guard let builder = self.listPolicyRulesWithRequestBuilder(policyId: policyId) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter policyId: (path)  
     - parameter completion: completion handler to receive the result
     */
    func listPolicyRules(policyId: String, completion: @escaping ((_ result: Swift.Result<[PolicyRule], Error>) -> Void)) {
        guard let builder = listPolicyRulesWithRequestBuilder(policyId: policyId) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func listPolicyRulesWithRequestBuilder(policyId: String) -> RequestBuilder<[PolicyRule]>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/policies/{policyId}/rules"
        let policyIdPreEscape = "\(APIHelper.mapValueToPathItem(policyId))"
        let policyIdPostEscape = policyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{policyId}", with: policyIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<[PolicyRule]>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter policyId: (path)  
     - parameter policy: (body)  
     - returns: AnyPublisher<Policy, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func updatePolicy(policyId: String, policy: Policy) -> AnyPublisher<Policy, Error> {
        return Future<Policy, Error>.init { promise in
            guard let builder = self.updatePolicyWithRequestBuilder(policyId: policyId, policy: policy) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter policyId: (path)  
     - parameter policy: (body)  
     - parameter completion: completion handler to receive the result
     */
    func updatePolicy(policyId: String, policy: Policy, completion: @escaping ((_ result: Swift.Result<Policy, Error>) -> Void)) {
        guard let builder = updatePolicyWithRequestBuilder(policyId: policyId, policy: policy) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func updatePolicyWithRequestBuilder(policyId: String, policy: Policy) -> RequestBuilder<Policy>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/policies/{policyId}"
        let policyIdPreEscape = "\(APIHelper.mapValueToPathItem(policyId))"
        let policyIdPostEscape = policyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{policyId}", with: policyIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: policy)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<Policy>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "PUT", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**

     - parameter policyId: (path)  
     - parameter ruleId: (path)  
     - parameter policyRule: (body)  
     - returns: AnyPublisher<PolicyRule, Error>
     */
    #if canImport(Combine)
    @available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func updatePolicyRule(policyId: String, ruleId: String, policyRule: PolicyRule) -> AnyPublisher<PolicyRule, Error> {
        return Future<PolicyRule, Error>.init { promise in
            guard let builder = self.updatePolicyRuleWithRequestBuilder(policyId: policyId, ruleId: ruleId, policyRule: policyRule) else {
                promise(.failure(DecodableRequestBuilderError.nilAPI))
                return
            }
            builder.execute { result -> Void in
                switch result {
                case let .success(response):
                    promise(.success(response.body!))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
    #endif
    /**

     - parameter policyId: (path)  
     - parameter ruleId: (path)  
     - parameter policyRule: (body)  
     - parameter completion: completion handler to receive the result
     */
    func updatePolicyRule(policyId: String, ruleId: String, policyRule: PolicyRule, completion: @escaping ((_ result: Swift.Result<PolicyRule, Error>) -> Void)) {
        guard let builder = updatePolicyRuleWithRequestBuilder(policyId: policyId, ruleId: ruleId, policyRule: policyRule) else {
            completion(.failure(DecodableRequestBuilderError.nilAPI))
            return
        }
        builder.execute { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    internal func updatePolicyRuleWithRequestBuilder(policyId: String, ruleId: String, policyRule: PolicyRule) -> RequestBuilder<PolicyRule>? {
        guard let api = api else {
            return nil
        }
        var path = "/api/v1/policies/{policyId}/rules/{ruleId}"
        let policyIdPreEscape = "\(APIHelper.mapValueToPathItem(policyId))"
        let policyIdPostEscape = policyIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{policyId}", with: policyIdPostEscape, options: .literal, range: nil)
        let ruleIdPreEscape = "\(APIHelper.mapValueToPathItem(ruleId))"
        let ruleIdPostEscape = ruleIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{ruleId}", with: ruleIdPostEscape, options: .literal, range: nil)
        let URLString = api.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: policyRule)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        var headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)
        headerParameters.merge(api.customHeaders) { lhs, rhs in
            return lhs
        }

        let requestBuilder: RequestBuilder<PolicyRule>.Type = api.requestBuilderFactory.getBuilder()

        return requestBuilder.init(api: api, method: "PUT", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

}
}
